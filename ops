{"version":1,"ops":[{"type":5,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1478859042,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDg1NTcxOTE2OQ=="},"added":["enhancement"],"removed":[]},{"type":2,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1478859343,"metadata":{"github-id":"MDE3OlJlbmFtZWRUaXRsZUV2ZW50ODU1NzI0NTEy"},"title":"tracing jit","was":"tracing jit"},{"type":3,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1484473239,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI3MjY4NDI5NQ==","github-url":"https://github.com/perl11/cperl/issues/220#issuecomment-272684295"},"message":"But first we will start with a very simple method jit in LLVM, to benchmark the cost/benefit ratio for the simple \n```\nPL_op = Perl_pp_enter(aTHX);\nPL_op = Perl_pp_nextstate(aTHX);\n...\nPL_op = Perl_pp_leave(aTHX);\n``` \nlinearization, and do the simple and easiest op optimizations at first. esp. nextstate which is currently the most costly op, esp. unneeded stack reset on every single line. The jit knows the stack depth for most simple ops, and can easily bypass that (#18). The jit also knows about locals and tainted vars.\n\nThen we can start counting calls and loops, and switch between the jit and bytecode runloop, if beneficial. The question is if the LLVM optimizer can inline the ops, or if it needs the IR of it. e.g. unladen_swallow needed to compile a complete libpython.bc runtime, and still needed a huge and slow LLVM abstraction library to emit the IR.\n\nSee the `feature/gh220-llvmjit` branch.","files":null}]}