{"version":1,"ops":[{"type":2,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1489504307,"metadata":{"github-id":"MDE3OlJlbmFtZWRUaXRsZUV2ZW50OTk5MjIzOTA1"},"title":"Add S06 macros","was":"Add S06 macros"},{"type":3,"author":{"id":"32244a9a8a40e2dff6ce5aa5b6e2aa421ebd286a"},"timestamp":1489505332,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI4NjQ1Nzc4Ng==","github-url":"https://github.com/perl11/cperl/issues/261#issuecomment-286457786"},"message":"There are a lot of questions stemming from this document. How do you do hygiene? I seem to remember you're a CL enthusiast(?) so you might not bother, but CL needs to execute code to know even how to parse what's coming next. I'm interested in your take on this.\n\nStuff like `macro f() { quasi { my $c = 1; } }; f(); say $c;` (or really, adding anything to the scope) is something @masak and everyone else working on [007](https://github.com/masak/007) have talked a lot about, often in the #6macros freenode channel.","files":null},{"type":3,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1489505474,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI4NjQ1ODU3MA==","github-url":"https://github.com/perl11/cperl/issues/261#issuecomment-286458570"},"message":"Hygiene is hard with this non-hygienic syntax. For proper hygiene you would need pattern matching as in scheme. But the existing tests should pass.\nI'll push the branch soon.","files":null},{"type":3,"author":{"id":"32244a9a8a40e2dff6ce5aa5b6e2aa421ebd286a"},"timestamp":1489505581,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI4NjQ1OTE5MA==","github-url":"https://github.com/perl11/cperl/issues/261#issuecomment-286459190"},"message":"Okay, so I'm even more interested to see how you'd generate identifiers. Waiting for the branch push. Thanks.","files":null},{"type":3,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1489505753,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI4NjQ2MDA5Mg==","github-url":"https://github.com/perl11/cperl/issues/261#issuecomment-286460092"},"message":"Just the tests yet, to get the syntax right.\nLexicals are hygienic as they are referred to by index, not by name. So they don't need gensym.","files":null},{"type":3,"author":{"id":"32244a9a8a40e2dff6ce5aa5b6e2aa421ebd286a"},"timestamp":1489505922,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI4NjQ2MTA0Nw==","github-url":"https://github.com/perl11/cperl/issues/261#issuecomment-286461047"},"message":"Okay, so you don't plan to make possible to break hygiene, or do you intend to make `COMPILING` work for this purpose? (it seems the test file is still somewhat rough, since `#todo rakudo` are still present)","files":null},{"type":3,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1489506130,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI4NjQ2MjI0OQ==","github-url":"https://github.com/perl11/cperl/issues/261#issuecomment-286462249"},"message":"COMPILING sounds easiest. But I'll wait for the perl6 decisions. I just want to implement the already working parts, sans the generally unliked `{{{` syntax.\nHygiene is relative with such lexicals as looking up the variable by name will not really work. Similar to the inliner, which needs to create copies with the same name. GCC adds hidden .1 suffices to such copies. Basically macro is very similar to inlining. I'll use the inlining functions in the compiler.","files":null},{"type":3,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1489506479,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI4NjQ2NDI1OQ==","github-url":"https://github.com/perl11/cperl/issues/261#issuecomment-286464259"},"message":"re compile-time \\`\\` syntax vs '{{{ }}}':\nI prefer this syntax and proposed it to Larry some years ago.\n* it resembles the lisp `, quasi/backtick syntax\n* it is semantically similar to qx()/'``' as result of expansion in a subprocess.\n* it is already supported by the syntax highlighter.\n* qx() is still usable within macros, so there's no conflict.","files":null},{"type":3,"author":{"id":"32244a9a8a40e2dff6ce5aa5b6e2aa421ebd286a"},"timestamp":1489506742,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI4NjQ2NTY4NA==","github-url":"https://github.com/perl11/cperl/issues/261#issuecomment-286465684"},"message":"That's down to bikeshedding, but we sometimes ago talked about \\` being somewhat a sigil, so ```quasi { `{$ast} }``` would be used. It's backwards with lisp's quote, and I don't think perl 5/6 needs multi-level unquotes (as opposed to Lisp's infamous ``` `(fn1 `(fn2 ,',var)) ```)","files":null},{"type":3,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1489506916,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI4NjQ2NjY1Mg==","github-url":"https://github.com/perl11/cperl/issues/261#issuecomment-286466652"},"message":"yes, it's pure bikeshedding. multi-level quote/unquote is still possible though. question is who wants to write such unreadable code. we will see. *(Note to myself: eventually track parser/compiler recursion depth, max 500)*\nobject systems need hygienic macros desperately.","files":null},{"type":5,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1490528452,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDEwMTU2NDg5MzM="},"added":["enhancement"],"removed":[]}]}