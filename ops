{"version":1,"ops":[{"type":1,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1461400623,"metadata":{"github-id":"MDU6SXNzdWUxNTA1MzI4NzI=","github-url":"https://github.com/perl11/cperl/issues/138","origin":"github"},"title":"optimize loops for the common cases","message":"add special faster ops for pp_iter:\n- iter_ary `for (@array)`\n- iter_lazyiv `for (0..9)`\n  without REVERSED support, and a new compile-time check for invalid decrementing range.\n\n---\n- enteriter is always followed by iter, and: **enteriter - iter - and**\n- iter is either after enteriter (first iter) or unstack (subsequent): **unstack - iter - and**\n  unstack being the nextop.\n- `for $sv ()` is always converted to a rv2gv - gv tree, implicit `for ()` uses a single gv only.\nA non-lexical scalar itervar $sv can be converted to a single gvsv without OPf_REF, to seperate it from `for \\$sv ()`. enteriter/cx_pushloop_for wants a gv/sv CXp_FOR_GV. Replace CXp_FOR_GV with CXp_FOR_SV. Does a GVSV -\u003e GvSV(defgv) make gv - defgv slower?\nThis should be changed to allow fast non-lexical GVSV itervars, initializing the new glob with rv2gv only once, not at every loop step. Only implicit $_ is pretty fast this way, as it does not need a rv2gv deref.\n\ninline OP_AND into OP_ITER. The AND always acts either on yes or no (produced by iter). so convert iter from base to an UNOP or LOGOP, with first (ignored), other: yes (continue), next: no (leaveloop).\n\n---\n\nold analysis for 5.22-style loops:\ncase 1: `for (...) {}`\n\n=\u003e **pp_iter_def** op\n\n  stacked\n  CXt_LOOP_FOR\n  itervar: GvSV(PL_defgv)  \n  av_is_stack (!cx-\u003eblk_loop.state_u.ary.ary)\n  !(PL_op-\u003eop_private \u0026 OPpITER_REVERSED)\n  !(SvMAGICAL(av) || AvREIFY(av))\n  !(cx-\u003ecx_type \u0026 CXp_FOR_LVREF)\n\ncase 2: `for my $var (...) { }`\n\n=\u003e **pp_iter_lex** op\n\n  !(PL_op-\u003eop_private \u0026 OPpITER_REVERSED)\n  !(SvMAGICAL(av) || AvREIFY(av))\n  !(cx-\u003ecx_type \u0026 CXp_FOR_LVREF)\n\ncase 3: `for (0..10) {}`\n\nwith the block consisting of const iv ranges. the temp. setiv can be optimized then (to defgv or a lexical)","files":null}]}