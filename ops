{"version":1,"ops":[{"type":1,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1466847065,"metadata":{"github-id":"MDU6SXNzdWUxNjIyNzI4NDY=","github-url":"https://github.com/perl11/cperl/issues/173","origin":"github"},"title":"sig2pp wrong @_","message":"1. The args are not copied from the pad (was: ~stack~) to @_. Tests added to `t/op/signatures.t` and `lib/perl5db.t` (fixed)\n2. If @_ is prev. undef it is not restored correctly, and the sig2pp code relies on a valid @_ (assertions).\n   See `t/op/goto.t` (fixed)\n3. One stack value under specific conditions is kept uninitialized but read from, to be copied to $_[1] in the crashing test goto2_sig2pp without DEBUGGING in `t/op/signatures.t`, probably caused by a SKIP directive in the previous sig, leaving the stack there uninitialized.\n   The problem is that we need to copy from the pad, because the SIGNATURE before goto moved the stack to the pad already, and the stack is now uninitialized.\n4. leave_scope in pp_goto deleted the padvars which needed to be copied to @_. before only @_ needed to be protected. don't do a leave_scope when coming from a sig, to keep the tailcall semantics\n\nwork in branch `bugfix/gh167-siggoto-d`\n\nSee also #134 \n\n```\nsub t147_pp {\n  my ($x, $y, $a, $b) = @_;\n  $a //= \"bar\";\n  $b //= \"zoot\";\n  print \"# t147_pp: $a:$b\\n\";\n  is \"$a:$b\", \"baz:7\";\n}\nsub goto1_sig2pp ($, $=0, $a=\"baz\", $b=\"7\") {\n  local @_ = (1,2,\"baz\",7); # ignored, should warn\n  goto \u0026t147_pp;\n}\nsub goto2_sig2pp ($x, $y, $a, $b) {\n  goto \u0026t147_pp; # crashes\n}\n\ngoto1_sig2pp(0); # 1st time ok\ngoto2_sig2pp(0,0,\"baz\",7); #crashes\n```","files":null}]}