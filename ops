{"version":1,"ops":[{"type":5,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1451517035,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDUwMzEyMjg3MQ=="},"added":["enhancement"],"removed":[]},{"type":3,"author":{"id":"7e7de3b2e4897d7a86200ba398a14aa4906d75b5"},"timestamp":1461783538,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDIxNTE5MzYwNg==","github-url":"https://github.com/perl11/cperl/issues/102#issuecomment-215193606"},"message":"I estimate you can use linear or serial (unsorted) lookup up to 100 keys or even more, depending on benchmarks.\n\nIn my port of [LCS::BV](https://github.com/wollmers/LCS-BV/tree/master/lib/LCS) from Perl to C I began with Bob Jenkins hash and ended the tuning using VLAs (variable length arrays) on the stack, the array serially filled (\\0 terminated). See [llcs_seq_a()](https://github.com/wollmers/c-lcs-bv/blob/master/lcstest.c#L105) and the used `hash_setpos()` and `hash_getpos()`. With Bob Jenkins I get 250 kHz (cases per second) on i5@1500, with serial VLAs 7.5 MHz, thus factor 30x. The `calloc` variant [llcs_seq()](https://github.com/wollmers/c-lcs-bv/blob/master/lcstest.c#L144) comes at 4 MHz.\n\nOf course in my example I can benefit from the known restrictions: maximum size, keys strings immutable, typed values (uint_64).","files":null},{"type":3,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1461796286,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDIxNTI1MTE4Ng==","github-url":"https://github.com/perl11/cperl/issues/102#issuecomment-215251186"},"message":"So many? I thought I only want to fill one cache line, so just very few\nkeys. But I'll benchmark it soon, when I got more time. Other langs tested\n3-5, if I remember.\n\nOn Wed, Apr 27, 2016, 20:59 Helmut Wollmersdorfer notifications@github.com\nwrote:\n\n\u003e I estimate you can use linear or serial (unsorted) lookup up to 100 keys\n\u003e or even more, depending on benchmarks.\n\u003e \n\u003e In my port of LCS::BV\n\u003e https://github.com/wollmers/LCS-BV/tree/master/lib/LCS from Perl to C I\n\u003e began with Bob Jenkins hash and ended the tuning using VLAs (variable\n\u003e length arrays) on the stack, the array serially filled (\\0 terminated). See\n\u003e llcs_seq_a()\n\u003e https://github.com/wollmers/c-lcs-bv/blob/master/lcstest.c#L105 and the\n\u003e used hash_setpos() and hash_getpos(). With Bob Jenkins I get 250 kHz\n\u003e (cases per second) on i5@1500, with serial VLAs 7.5 MHz, thus factor 30x.\n\u003e The calloc variant llcs_seq()\n\u003e https://github.com/wollmers/c-lcs-bv/blob/master/lcstest.c#L144 comes\n\u003e at 4 MHz.\n\u003e \n\u003e Of course in my example I can benefit from the known restrictions: maximum\n\u003e size, keys strings immutable, typed values (uint_64).\n\u003e \n\u003e â€”\n\u003e You are receiving this because you were assigned.\n\u003e Reply to this email directly or view it on GitHub\n\u003e https://github.com/perl11/cperl/issues/102#issuecomment-215193606","files":null},{"type":3,"author":{"id":"7e7de3b2e4897d7a86200ba398a14aa4906d75b5"},"timestamp":1461834357,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDIxNTM1OTU1Nw==","github-url":"https://github.com/perl11/cperl/issues/102#issuecomment-215359557"},"message":"You should trust only numbers you benchmarked yourself;-)\n\nHash is said to have complexity O(1). But as always it is O(1*k), where k is the implementation factor.\n\nSerial has O((n/2)*k). A break even point of n=4 between hash and serial would need k_hash = 2 \\* k_serial. I.e. the hash algorithm executes only the double amount of instructions compared to one iteration of the loop of serial. My serial has 3 instructions (C operators) in the loop including conditions. So for a break even n=4 it would need a hash function (locating the entry in the array) to only use 6 instructions.\n\nI didn't optimize for cache friendlyness directly. Serial just maps a nearly indefinite (sparse) alphabet to a minimal one (none sparse) and keeps nearly the order of filling, which is memory and cache friendly. Hash algorithms (if not perfect hashes) map sparse to not so sparse, but still sparse.","files":null},{"type":3,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1468775134,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDIzMzE5MjE0Ng==","github-url":"https://github.com/perl11/cperl/issues/102#issuecomment-233192146"},"message":"I went with 7 because this is the initial calloced size. But it doesn't work yet, so I cannot benchmark it.","files":null},{"type":3,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1471589151,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI0MDk0MTI1Mw==","github-url":"https://github.com/perl11/cperl/issues/102#issuecomment-240941253"},"message":"Merged the 3 first parts (ctz, hv_common_magical, pre-extend). \nIn the end it was much faster than expected. On my linux gcc-6.1/i5-2300 it was 8-14% faster in perlbench-run, on my darwin gcc-6-lto/i7-4650U 6% faster.\n\nHaving the magical code seperated and abstracted away will also help in the future hash rewrites.","files":null},{"type":4,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1471589151,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50NzYwODg1MjQ2"},"status":2},{"type":4,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1471589219,"metadata":{"github-id":"MDEzOlJlb3BlbmVkRXZlbnQ3NjA4ODYxNDc="},"status":1},{"type":5,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1480581588,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDg3ODExMDAyOQ=="},"added":["in progress"],"removed":[]},{"type":5,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1490872553,"metadata":{"github-id":"MDE0OlVubGFiZWxlZEV2ZW50MTAyMjEwOTE3Mg=="},"added":[],"removed":["in progress"]}]}