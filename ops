{"version":1,"ops":[{"type":5,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1467875107,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDcxNTMyNzk0OA=="},"added":["enhancement"],"removed":[]},{"type":5,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1467875107,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDcxNTMyNzk0OQ=="},"added":["upstream"],"removed":[]},{"type":2,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1467875206,"metadata":{"github-id":"MDE3OlJlbmFtZWRUaXRsZUV2ZW50NzE1MzI5MTQw"},"title":"recycle eval code and data","was":"recycle eval-string code and data"},{"type":2,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1467875220,"metadata":{"github-id":"MDE3OlJlbmFtZWRUaXRsZUV2ZW50NzE1MzI5Mjcy"},"title":"recycle eval-string code and data","was":"recycle eval code and data"},{"type":3,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1467875380,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDIzMTAwMDQwMw==","github-url":"https://github.com/perl11/cperl/issues/178#issuecomment-231000403"},"message":"It's not really a leak. eval-string created global code is never recycled at scope-end, only released during global destruction.\nThis is because all non-lexical subs are global, thus must be kept in memory.\nIf you want them to go out of scope use lexical subs.\n\nUnfortunately all simple macro schemes, via string builders, as used by most perl oo frameworks, e.g. Moose use this to create global methods.\n\nWhat you need to do is to undef such unwanted globals subs after usage.\n\nIf you need to use globals subs, try at least to globalize the memory hogs. With my, our local they are allocated separately. If global there's only big instance kept in memory, but you loose encapsulation.\n\nnot a bug","files":null},{"type":3,"author":{"id":"2061c43c01102efb065766caee8a1ddfe3b31505"},"timestamp":1467876442,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDIzMTAwMzQ2NQ==","github-url":"https://github.com/perl11/cperl/issues/178#issuecomment-231003465"},"message":"I used eval only for creating 20 \"real\" subs, if you create manual 20 subs there will be same effect","files":null},{"type":4,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1467876722,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50NzE1MzQ5NjQw"},"status":2},{"type":5,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1467876751,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDcxNTM1MDA2Mw=="},"added":["wontfix"],"removed":[]},{"type":5,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1467876751,"metadata":{"github-id":"MDE0OlVubGFiZWxlZEV2ZW50NzE1MzUwMDY0"},"added":[],"removed":["enhancement"]},{"type":5,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1467876751,"metadata":{"github-id":"MDE0OlVubGFiZWxlZEV2ZW50NzE1MzUwMDY1"},"added":[],"removed":["upstream"]},{"type":3,"author":{"id":"2061c43c01102efb065766caee8a1ddfe3b31505"},"timestamp":1467878874,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDIzMTAxMTEzMw==","github-url":"https://github.com/perl11/cperl/issues/178#issuecomment-231011133"},"message":"with lexical sub it doubled twice and never return:\n\n```\nlog_mem_usage(\"start\");\n{\n    (sub { my $s = \"x\" x 500000000; })-\u003e();\n}\nlog_mem_usage(\"after\");\n\nstart      VSZ    RSS\n 2924660 489884\nafter       VSZ    RSS\n 3422160 978212\n```\n\nAs I understand first it preallocated at compile time, then called again, we can avoid this behavior using variable length:\n\n```\nlog_mem_usage(\"start\");\n{\n    (sub { my $i = 500000000; my $s = \"x\" x $i; })-\u003e();\n}\nlog_mem_usage(\"after\");\n\nstart      VSZ    RSS\n 2445588   1604\nafter       VSZ    RSS\n 2933876 489936\n```\n\nbut mem also never return:\n\n```\nlog_mem_usage(\"start\");\n(sub { my $i = 500000000; my $s = \"x\" x $i; })-\u003e(); log_mem_usage(\"after 1\");\n(sub { my $i = 500000000; my $s = \"x\" x $i; })-\u003e(); log_mem_usage(\"after 2\");\n(sub { my $i = 500000000; my $s = \"x\" x $i; })-\u003e(); log_mem_usage(\"after 3\");\n(sub { my $i = 500000000; my $s = \"x\" x $i; })-\u003e(); log_mem_usage(\"after 4\");\n(sub { my $i = 500000000; my $s = \"x\" x $i; })-\u003e(); log_mem_usage(\"after 5\");\n\nstart      VSZ    RSS\n 2455828   1644\nafter 1      VSZ    RSS\n 2944116 489972\nafter 2      VSZ    RSS\n 3432400 778820\nafter 3      VSZ    RSS\n 3920684 1044500\nafter 4      VSZ    RSS\n 4408968 1194196\nafter 5      VSZ    RSS\n 4897252 1267140\n```\n\none more strange example use 4gb+:\n\n```\nperl -e 'sub { my $t = \"x\" x (10 ** 10) }'\n```","files":null},{"type":3,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1467879007,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDIzMTAxMTUyNQ==","github-url":"https://github.com/perl11/cperl/issues/178#issuecomment-231011525"},"message":"As I explained, try it without the my in the sub. Then the data is only one global instance, not so many.\n\nWhat you call lexical sub was not a lexical sub. Currently they need to be named.\n\n```\nvalgrind --tool=massif ./perl -Ilib -E'{my sub x { my $s = \"x\" x 500000000;} x;}'\ngrep mem_heap_B massif.out.34973\n\n=\u003e\nmem_heap_B=381025\nmem_heap_B=500382567\nmem_heap_B=500382271\nmem_heap_B=1000372762\nmem_heap_B=366861\n```\n\nor using your code with lexical subs:\n\n```\n$ cperl -mexperimental=lexical_subs -E'sub ps{warn $_[0], \" \", `ps -p $$ -o vsz,rss`;} \n{my sub x { my $s = \"x\" x 500000000;} ps 1;x;ps 2;} ps 3'\n1      VSZ    RSS\n 2935904 490936\n2      VSZ    RSS\n 3426236 979264\n3      VSZ    RSS\n 2937952 490984\n```\n\nwith undef:\n\n```\n./perl -Ilib -mexperimental=lexical_subs -E'sub ps{warn $_[0], \" \", `ps -p $$ -o vsz,rss`;} \nno strict; for (0..3) { eval \"sub x$_ { my \\$s = q(x) x 500000000;}\"; ps $_.\"b\"; \"x$_\"-\u003e(); \nps $_.\"a\"; eval \"undef \\\u0026x$_\"; ps $_.\"del\"} ps \"after\"'\n\n0b      VSZ    RSS\n 2926688 492132\n0a      VSZ    RSS\n 3424188 980444\n0del      VSZ    RSS\n 2447620   3896\n1b      VSZ    RSS\n 2935904 492184\n1a      VSZ    RSS\n 3424188 980468\n1del      VSZ    RSS\n 2447620   3900\n2b      VSZ    RSS\n 2935904 492188\n2a      VSZ    RSS\n 3424188 980472\n2del      VSZ    RSS\n 2456836   3928\n3b      VSZ    RSS\n 2945120 492216\n3a      VSZ    RSS\n 3433404 980500\n3del      VSZ    RSS\n 2456836   3932\nafter      VSZ    RSS\n 2456836   3932\n```\n\nyou can also undef it in a separate loop, when you don't need those subs anymore.\n\nwith a global it's not as good as via explicit undef'ing of course:\n\n```\n$ ./perl -Ilib -mexperimental=lexical_subs -E'sub ps{warn $_[0], \" \", `ps -p $$ -o vsz,rss`;} \nno strict; \nfor (0..3) { eval \"sub x$_ { \\$s = q(x) x 500000000;}\"; ps $_.\"b\"; \"x$_\"-\u003e(); ps $_.\"a\"; } \nps \"after\"'\n\n0b      VSZ    RSS\n 2926688 492128\n0a      VSZ    RSS\n 3424188 980440\n1b      VSZ    RSS\n 3912472 1468744\n1a      VSZ    RSS\n 3912472 1468744\n2b      VSZ    RSS\n 4400756 1957028\n2a      VSZ    RSS\n 4400756 1957028\n3b      VSZ    RSS\n 4890064 2445332\n3a      VSZ    RSS\n 4891088 2445348\nafter      VSZ    RSS\n 4891088 2445348\n```","files":null},{"type":4,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1467879007,"metadata":{"github-id":"MDEzOlJlb3BlbmVkRXZlbnQ3MTUzODMxMDE="},"status":1},{"type":4,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1467879317,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50NzE1Mzg3NzEx"},"status":2},{"type":3,"author":{"id":"2061c43c01102efb065766caee8a1ddfe3b31505"},"timestamp":1467880670,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDIzMTAxNzM4Mw==","github-url":"https://github.com/perl11/cperl/issues/178#issuecomment-231017383"},"message":"ok, with real lexical subs it just 3 time triple:\n\n```\nlog_mem_usage(\"start\");\n$s = \"x\" x 500000000;\nlog_mem_usage(\"create\");\n\n{  my sub process { my $t = \"avoid cow\" . shift }; process($s); log_mem_usage(\"after 1\") }\n{  my sub process2 { my $t = \"avoid cow\" . shift }; process2($s); log_mem_usage(\"after 2\") };\n{  my sub process3 { my $t = \"avoid cow\" . shift }; process3($s); log_mem_usage(\"after 3\") };\n\nstart      VSZ    RSS\n 2934204 490120\ncreate      VSZ    RSS\n 3422488 978408\nafter 1      VSZ    RSS\n 3910772 1466704\nafter 2      VSZ    RSS\n 3919988 1366944\nafter 3      VSZ    RSS\n 3919988 1414124\n```\n\nbut real scripts(e.g. 99% code from cpan) looks like this:\n\n```\nlog_mem_usage(\"start\");\n$s = \"x\" x 500000000;\nlog_mem_usage(\"create\");\n\nsub process1 { my $t = \"avoid cow\" . shift };\nsub process2 { my $t = \"avoid cow\" . shift };\nsub process3 { my $t = \"avoid cow\" . shift };\nsub process4 { my $t = \"avoid cow\" . shift };\nsub process5 { my $t = \"avoid cow\" . shift };\n\nprocess1($s); log_mem_usage(\"after 1\");\nprocess2($s); log_mem_usage(\"after 2\");\nprocess3($s); log_mem_usage(\"after 3\");\nprocess4($s); log_mem_usage(\"after 4\");\nprocess5($s); log_mem_usage(\"after 5\");\n\nstart      VSZ    RSS\n 2944444 490140\ncreate      VSZ    RSS\n 3440920 928500\nafter 1      VSZ    RSS\n 3929204 1436808\nafter 2      VSZ    RSS\n 4417488 1629832\nafter 3      VSZ    RSS\n 4905772 1790792\nafter 4      VSZ    RSS\n 5394056 1864940\nafter 5      VSZ    RSS\n 5882340 2033088\n```\n\nso when big data chunk is appear in each sub it grow and never return memory back, and memory usage depend on how many subs you have\nis it acceptable ?","files":null},{"type":3,"author":{"id":"2061c43c01102efb065766caee8a1ddfe3b31505"},"timestamp":1467880907,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDIzMTAxODI0Ng==","github-url":"https://github.com/perl11/cperl/issues/178#issuecomment-231018246"},"message":"I see I can free memory manual:\n\n```\nsub process1 { my $t = \"avoid cow\" . shift; undef $t };\nsub process2 { my $t = \"avoid cow\" . shift; undef $t };\nsub process3 { my $t = \"avoid cow\" . shift; undef $t };\nsub process4 { my $t = \"avoid cow\" . shift; undef $t };\nsub process5 { my $t = \"avoid cow\" . shift; undef $t };\n\nstart      VSZ    RSS\n 2944444 490132\ncreate      VSZ    RSS\n 3440920 902536\nafter 1      VSZ    RSS\n 3440920 896156\nafter 2      VSZ    RSS\n 3440920 896196\nafter 3      VSZ    RSS\n 3440920 896196\nafter 4      VSZ    RSS\n 3440920 896196\nafter 5      VSZ    RSS\n 3440920 896196\n```\n\nwhy don't do this automaticaly?","files":null},{"type":4,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1467895777,"metadata":{"github-id":"MDEzOlJlb3BlbmVkRXZlbnQ3MTU2NjE2NDM="},"status":1},{"type":3,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1467895903,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDIzMTA2ODI1Ng==","github-url":"https://github.com/perl11/cperl/issues/178#issuecomment-231068256"},"message":"This is now a different case. Here we have a couple of global subs, which are only destroyed at the end.\nAll of them carry lexicals in their pad. These lexicals have to be carried around also,\nbecause you might close over them, and need those distinct values.\n\nstill not a bug.","files":null},{"type":4,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1467895903,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50NzE1NjY0MDUw"},"status":2},{"type":3,"author":{"id":"2061c43c01102efb065766caee8a1ddfe3b31505"},"timestamp":1467960424,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDIzMTI4NzcwOQ==","github-url":"https://github.com/perl11/cperl/issues/178#issuecomment-231287709"},"message":"Well, lets return to arrays, why this code leaking?\n\n```\nmy $Na = 5_000_000;\n\nlog_mem_usage(\"start\");\n\nmy $arr;\nfor(1..10) {\n    $arr = [ ];\n    push @$arr, $_ foreach 1 .. $Na;\n    log_mem_usage(\"create array\");\n\n    undef $arr;\n    log_mem_usage(\"free array\");\n};\n\nsub log_mem_usage {\n    warn $_[0], \" \", `ps -p $$ -o vsz,rss`;\n}\n\nstart      VSZ    RSS\n 2436372   1592\ncreate array      VSZ    RSS\n 2606616 166788\nfree array      VSZ    RSS\n 2606616 166920\ncreate array      VSZ    RSS\n 2652824 213256\nfree array      VSZ    RSS\n 2652824 213384\ncreate array      VSZ    RSS\n 2700056 259476\nfree array      VSZ    RSS\n 2700056 259604\ncreate array      VSZ    RSS\n 2746264 305684\nfree array      VSZ    RSS\n 2746264 305812\ncreate array      VSZ    RSS\n 2793496 351916\nfree array      VSZ    RSS\n 2793496 352044\ncreate array      VSZ    RSS\n 2839704 398124\nfree array      VSZ    RSS\n 2839704 398252\ncreate array      VSZ    RSS\n 2885912 444348\nfree array      VSZ    RSS\n 2885912 444476\ncreate array      VSZ    RSS\n 2932120 490556\nfree array      VSZ    RSS\n 2932120 490684\ncreate array      VSZ    RSS\n 2978328 536764\nfree array      VSZ    RSS\n 2978328 536900\ncreate array      VSZ    RSS\n 3024536 582980\nfree array      VSZ    RSS\n 3024536 583108\n```","files":null},{"type":3,"author":{"id":"2061c43c01102efb065766caee8a1ddfe3b31505"},"timestamp":1467971675,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDIzMTMyMTI2OQ==","github-url":"https://github.com/perl11/cperl/issues/178#issuecomment-231321269"},"message":"the leak depends on array size factor($Na) and iterations count, and not depend how array was created:\n\n```\nlog_mem_usage(\"start\");\n\nfor(1..100) {\n    eval 'my sub x' . $_ . ' {\n        my $arr = [ ];\n        push @$arr, $_ foreach 1 .. $Na;\n    };\n    x' . $_ . '();';\n\n    log_mem_usage($_);\n};\n\nlog_mem_usage(\"leave scope\");\n\n\nstart      VSZ    RSS\n 2464020   2784\n1      VSZ    RSS\n 2616856 168012\n2      VSZ    RSS\n 2663064 214412\n3      VSZ    RSS\n 2709272 260620\n4      VSZ    RSS\n 2755480 306828\n5      VSZ    RSS\n 2801688 353044\n6      VSZ    RSS\n 2847896 399252\n7      VSZ    RSS\n 2894104 445460\n8      VSZ    RSS\n 2940312 491668\n9      VSZ    RSS\n 2986520 537876\n10      VSZ    RSS\n 3032728 584084\n11      VSZ    RSS\n 3078936 630292\n12      VSZ    RSS\n 3125144 676500\n13      VSZ    RSS\n 3171352 722708\n14      VSZ    RSS\n 3217560 735404\n15      VSZ    RSS\n 3263768 736376\n16      VSZ    RSS\n 3263768 691996\n17      VSZ    RSS\n 3263768 690120\n18      VSZ    RSS\n 3263768 689568\n19      VSZ    RSS\n 3263768 689568\n20      VSZ    RSS\n 3263768 689076\n21      VSZ    RSS\n 3263768 689308\n22      VSZ    RSS\n 3263768 688864\n23      VSZ    RSS\n 3263768 732892\n24      VSZ    RSS\n 3263768 778140\n25      VSZ    RSS\n 3263768 814164\n26      VSZ    RSS\n 3263768 800380\n27      VSZ    RSS\n 3263768 814176\n28      VSZ    RSS\n 3263768 814192\n29      VSZ    RSS\n 3263768 814192\n```\n\nafter reaching ~800mb rss it stop increasing","files":null}]}