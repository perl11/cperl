{"version":1,"ops":[{"type":1,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1458388076,"metadata":{"github-id":"MDU6SXNzdWUxNDIwNTQ0NzA=","github-url":"https://github.com/perl11/cperl/issues/111","origin":"github"},"title":"HvSTATIC","message":"See #62 AvSTATIC. Do it for hashes analog to static arrays:\n\nAdd a HvSTATIC bit for the alloc ptrs, to protect them from free on scope exit, and global destruction.\n\nThis allows the compiler to statically allocate the HvARRAY array, and add COW or COG (copy-on-write, copy-on-grow)\n\nWe have 3 options in the compiler:\n\nCOW: put the static SV*\\* array as const into the .rodata segment. writes trigger cow, set SVf_READONLY and HvSTATIC flags\nCOG: put the static SV*\\* array not as const into the .data segment. writes are ok, extends trigger cow. HvSTATIC flag only.\nno static SV*\\* array, dynamic alloc in the compiler init, (preferably with ptmalloc3 _independent_comalloc and -fav-init2), no cow. no SVf_READONLY, no HvSTATIC.\n\nOne compiler branch already does this (cowbanga_remake). \nProblems with HvSTATIC overall:\nA hash specific seed needs to be baked into every static hash. If not, using a global compiled seed, we need a Hash flood prevention scheme, which is not doable for a compiler with perl5 upstream. Or only with insecure not public-facing binaries or JSON.\n\nFor the hash problem easiest would be to add a fast `hv_insert()` API to add a static HEK and value to a dynamic bucket, at the top, ignoring any special cases, like magic, lvalue, ...","files":null}]}