{"version":1,"ops":[{"type":1,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1441999302,"metadata":{"github-id":"MDU6SXNzdWUxMDYwNzY0ODE=","github-url":"https://github.com/perl11/cperl/issues/24","origin":"github"},"title":"new hash table","message":"The old hash table uses: \n- linked lists for its collisions, with slow out-of-cache pointer chasing and data overhead.\n- unsorted flags at the end, while some flags are needed for compare.\n- has questionable security measures to slow down all cases. seed ok, randomize iter maybe, but randomize the collisions and slow hash funcs is stupid. the security should be fixed with proper implementations, not by pseudo-security theatre.\n\neither use: \n- rurban/hash-sortbuckets: a sorted static list of collisions (up to 8, maybe start with 3, then 8) as in knuth sorted hash table, \n- khash: use open addressing as everyone else. faster, less space.\n- ✓ **PERTURB_KEYS_TOP** move-to-front with a linked list is the only sane strategy for simple chained bucket lists.\n- ✓ **HV_FILL_RATE**: try lower fill rates than 100%. 100% is pretty insane, esp. with our bad hash funcs. make it fast with builtin_ctz.\n- ✓ use __builtin_ctz for faster division in DO_HSPLIT. Allow -DHV_FILL_RATE=90 definition. (Tested to be the best with FNV1A)\n- **HE_ARRAY**: According to http://goanna.cs.rmit.edu.au/~jz/fulltext/spire05.pdf\n  the best for chained hashing is currently a cache-friendly array:\n  cache-friendly continuous buffer of HE's w/ inlined HEK (char_) + SV_ val, but no hash, no next ptr. Also for shared he's: PL_strtab.\n- ✓ **array_he**: inline parts of the HE into the array. array_he vs ll_he. (linked list, see also the he-array branch). array_he (`HvARRAY = AHE[]`) can contain `{ hent_he, hent_hash }`. this way the hash catches 99% of all comparisons already, and we don't have to chase the external hek ptr, when the hash check fails. every HE entry will then be 2 words (128), instead of one word (64), called AHE. The linked list still contains the old `HE*`, with `{ hent_next, hent_hek, hent_val }`.\n- **one-word-AHE**: As possible improvement on that on 64bit use 48bits for the HE ptr, and 16bits of the hash to be compared first. See https://www.semanticscholar.org/paper/Fast-Dynamically-Sized-Concurrent-Hash-Table-Barnat-Rockai/ab7dd007587f411cf99bfe056639e055eff22e0c/pdf\n- use **robin-hood** as this is currently the best worse-case strategy (being super defensive, but not so stupid to use SipHash, which adds no benefit). with better threading support (shared hashes) eventually use leapfrog.\n- **compact ordered hash**. use an array of short indices into a compacted array of hash/key/val entries as in PyPy and now python: \"compact ordered dict\". This saves a lot of space and only add's one indirect lookup into cache-friendly array. See https://github.com/methane/cpython/pull/1 https://mail.python.org/pipermail/python-dev/2016-September/146327.html\n  This also iterates over the hash in insertion order, which effectively hides any attempt to get the seed over the iterators. For attacks you need to get collision and robin-hood reordering timings.\n\n---\n\nmaybe use the glibc htable (hsearch, hcreate), just add random seeds and flood detection (collision counts). (or khash, which is basically the same). coucal looks good also. https://github.com/xroche/coucal\nbut best is probably preshing's http://preshing.com/20160314/leapfrog-probing/, which even can be made concurrent easily.\n\nopen addressing is cache friendly and much faster, but table growth is slow.\npotion uses khash, first double open, then quadratic open.\n\neither way, first I need to abstract away the collision search in MACROS\nand reduce the needed comparisons from 4 to 1. (edit: after my critic, they improved that part to one ptr cmp) \nmaybe we can normalize all keys to utf8 for faster checks. (_probably not_)\nutf8 is a HEK flag. See http://cpansearch.perl.org/src/RURBAN/illguts-0.49/index.html#hek\nThe current implementation is just insanity and it only got worse over the years.\n\nThe last attempt was here: https://github.com/rurban/perl/commits/rurban/hash-sortbuckets\nSee the `featurex/gh24-*hash*` branches.\nSee also GH #102 \n\n---\n## plan\n- ✓ -Dhash_func, add and test many more funcs\n- ✓ PERTURB_KEYS_TOP\n- ✓ HV_FILL_RATE\n- ✓ d_builtin_ctz\n- ✓ seperate hv_common_magic\n- ✓ security: warn and protect against hash flood\n- ✓ fix NODEFAULT_SHAREKEYS (#201)\n- ✓ hash_loop: abstract loops and array_he\n- ✓ array_he: seperate HvARRAY from collisions entries, add hent_hash\n- 80% new_hash_table: merge HE fields for faster loop, usehekbitfield, d_little_endian.\n- one-word-AHE (hash+he on 64bit)\n- 40% open_hash, compact_ordered: various strategies with the new abstractions","files":null}]}