%{/* -*- mode: c; c-basic-offset: 4; -*-

Copyright (C) 2015, cPanel Inc
Copyright (C) 2017, Reini Urban <rurban@cpan.org>

=head1 NAME

ext/warnings/warnings.xs - gperf generated read-only warnings hash as shared library

=head1 DESCRIPTION

Generated warnings hash from F<ext/warnings/warnings_xs.in>
via F<ext/warnings/warnings_xs.PL>

C<gperf --output-file=ext/warnings/warnings.xs ext/warnings/warnings_xs.in>
with cleanups for header, inline, C++ and c89.

The old external hashes C<%Bits>, C<%DeadBits> are tied to the
values in the const wordlist perfect hash.  Only the C<all> key is
writable, but the hash is extendable.  Every read-access goes first
through the perfect hash, and then into a normal perl hash, to be able
to register custom user-categories. We assume almost nobody needs to
create his own user category, so penalize this.

For "all", if C<%_Bits> exists, i.e. user category warnings were added, 
"all is taken from there, otherwise from the initial const hash.

=over 4

=item C<struct Perl_warnings>

Structure of generated read-only hash table with name, offsets, bits and deadbits.

=back

=head2 Functions

=over 4

=item C<struct Perl_warnings * Perl_warnings_lookup(register const
char *str, register unsigned int len)>

API function to access the generated hash.

=item C<struct Perl_warnings * warnings_const_lookup(register const
char *str, register unsigned int len)>

Generated lookup function to access to read-only compile-time part of the hash.

=back

=cut

*/

#define PERL_NO_GET_CONTEXT
#define PERL_EXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "warnings.h"

#define USE_PP_CARP 1
#define WNORMAL  1
#define WFATAL   2
#define WMESSAGE 4

typedef UV HASHOBJ;
#define AV_PUSH(av, val) av_store(av, AvFILLp(av)+1, val)

struct Perl_warnings { int name; const char *bits; const char *deadbits; const U8 offset; const U8 size; };
struct Perl_warnings_dyn { int name; char *bits; char *deadbits; U8 offset; U8 size; SV *base; };
struct Perl_warnings_dyn ws;
struct Perl_warnings_dyn wall;
struct Perl_warnings *
Perl_warnings_lookup (register const char *str, register unsigned int len);

%}
%language=ANSI-C
%struct-type
%define hash-function-name   warnings_hash
%define lookup-function-name warnings_const_lookup
%null-strings
%pic
%readonly-tables

struct Perl_warnings;
%%
all, WARN_ALLstring, WARN_DEADALLstring, 0, 19
closure, "\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 2, 19
deprecated, "\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 4, 19
exiting, "\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 6, 19
glob, "\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 8, 19
io, "\0\124\125\0\0\0\0\0\0\0\0\0\0\0\100\0\0\0\0", "\0\250\252\0\0\0\0\0\0\0\0\0\0\0\200\0\0\0\0", 10, 19
closed, "\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 12, 19
exec, "\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 14, 19
layer, "\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 16, 19
newline, "\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 18, 19
pipe, "\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 20, 19
unopened, "\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 22, 19
misc, "\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 24, 19
numeric, "\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 26, 19
once, "\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 28, 19
overflow, "\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 30, 19
pack, "\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 32, 19
portable, "\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 34, 19
recursion, "\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 36, 19
redefine, "\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 38, 19
regexp, "\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0", 40, 19
severe, "\0\0\0\0\0\124\5\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\250\12\0\0\0\0\0\0\0\0\0\0\0\0", 42, 19
debugging, "\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0", 44, 19
inplace, "\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0", 46, 19
internal, "\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0", 48, 19
malloc, "\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0", 50, 19
signal, "\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0", 52, 19
substr, "\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0", 54, 19
syntax, "\0\0\0\0\0\0\0\125\125\25\0\100\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\252\252\52\0\200\0\0\0\0\0\0\0", 56, 19
ambiguous, "\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0", 58, 19
bareword, "\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0", 60, 19
digit, "\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0", 62, 19
parenthesis, "\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0", 64, 19
precedence, "\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0", 66, 19
printf, "\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0", 68, 19
prototype, "\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0", 70, 19
qw, "\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0", 72, 19
reserved, "\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0", 74, 19
semicolon, "\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0", 76, 19
taint, "\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0", 78, 19
threads, "\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0", 80, 19
uninitialized, "\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0", 82, 19
unpack, "\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0", 84, 19
untie, "\0\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0", 86, 19
utf8, "\0\0\0\0\0\0\0\0\0\0\0\1\25\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\2\52\0\0\0\0\0\0", 88, 19
void, "\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0", 90, 19
imprecision, "\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0", 92, 19
illegalproto, "\0\0\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0", 94, 19
non_unicode, "\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0", 96, 19
nonchar, "\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0", 98, 19
surrogate, "\0\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0", 100, 19
experimental, "\0\0\0\0\0\0\0\0\0\0\0\0\100\125\25\125\1\104\1", "\0\0\0\0\0\0\0\0\0\0\0\0\200\252\52\252\2\210\2", 102, 19
experimental::lexical_subs, "\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0", 104, 19
experimental::lexical_topic, "\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0", 106, 19
experimental::regex_sets, "\0\0\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0", 108, 19
experimental::smartmatch, "\0\0\0\0\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0", 110, 19
experimental::autoderef, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0", 112, 19
experimental::postderef, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0", 114, 19
experimental::signatures, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0", 116, 19
syscalls, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\100\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\200\0\0\0\0", 118, 19
experimental::bitwise, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0", 120, 19
experimental::const_attr, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0", 122, 19
experimental::re_strict, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\40\0\0\0", 124, 19
experimental::refaliasing, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\100\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\200\0\0\0", 126, 19
experimental::win32_perlio, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0", 128, 19
locale, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0", 130, 19
missing, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\20\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\40\0\0", 132, 19
redundant, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\100\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\200\0\0", 134, 19
types, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0", 136, 19
experimental::declared_refs, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0", 138, 19
security, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\20\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\40\0", 140, 19
experimental::alpha_assertions, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\100\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\200\0", 142, 19
experimental::script_run, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2", 144, 19
shadow, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10", 146, 19
%%

/* We really need to zero the bits */
static SV *
newWSV(const char *str, const int len) {
    int nlen = len ? len : WARN_MAX_BYTES;
    SV *sv = newSV(nlen);
    /*SvUPGRADE(sv, SVt_PV); --unneeded*/
    SvCUR_set(sv, nlen);
    SvPOK_on(sv);
    Zero(SvPVX(sv), nlen, char);
    if (len)
        Move(str, SvPVX(sv), len, char);
    return sv;
}

/* static compile-time length */
#define newWSVpvs(str) newWSV(STR_WITH_LEN(str))
/* dynamic max length */
#define newWSVpv(str) newWSV(str, WARN_MAX_BYTES)
/* static length from header */
#define newWSVpvh(str) newWSV(str, WARNsize)

struct Perl_warnings *
Perl_warnings_lookup (register const char *str, register unsigned int len) {
    const struct Perl_warnings *w = warnings_const_lookup(str, len);
    const bool is_all = memEQs(str, len, "all");
    if (is_all || !w) {
        SV **bit;
        HV * const bits = get_hv("warnings::_Bits", 0);
        if (bits && HvTOTALKEYS(bits)) {
            SvREADONLY_off(bits);
            if ((bit = hv_fetch(bits, str, len, FALSE))) {
                char *p = SvPVX(*bit);
                /* use the static temp. buffer */
                struct Perl_warnings_dyn *wd = is_all ? &wall : &ws;
                STRLEN l = SvCUR(*bit) / 2;
                wd->bits     = p;
                wd->deadbits = p + l;
                wd->offset   = SvIVX(*bit);
                wd->size     = l;
                wd->base     = *bit;
                SvREADONLY_on(bits);
                return (struct Perl_warnings *)wd;
            }
            SvREADONLY_on(bits);
        } else if (is_all) { /* old all */
            return (struct Perl_warnings *)w;
        } else {
            return NULL;
        }
    }
    return (struct Perl_warnings *)w;
}

static int _chk(const char *sub, const U32 flags, I32 ax) {
    dSP;
    SV **mark = PL_stack_base + ax - 1;
    dITEMS;
    SV *message, *mask;
    char *category;
    const struct Perl_warnings *w;
    const PERL_CONTEXT *cx;
    int i, is_obj = 0;
    int has_message = flags & WMESSAGE;
    int results_0 = 0, results_1 = 0;
    STRLEN * old_warnings;

    if (!(items == 1 || items == (has_message ? 2 : 0))) {
#ifdef USE_PP_CARP
        SV *msg = newSVpvs("");
        sv_catpvf(msg, "Usage: warnings::%s(%s)", sub, has_message
                  ? "[category,] 'message'" : "[category]");
        PUSHMARK(SP);
        mXPUSHs(msg);
        PUTBACK;
        call_pv("warnings::Croaker", G_DISCARD);
        SPAGAIN;
#else
        /*croak_sv(carp_shortmess(ax, msg));*/
        croak("Usage: warnings::%s(%s)", sub, has_message
              ? "[category,] 'message'" : "[category]");
#endif
    }
    if (has_message) {
        message = items == 1 ? ST(0) : ST(1);
        if (SvREADONLY(message))
            message = newSVpvn(SvPVX(message), SvCUR(message));
        items--;
    } else {
        message = newSVpvs("");
    }
    if (items > 0) {
        if (SvOBJECT(ST(0))) {
            category = HvNAME(SvSTASH(ST(0)));
            is_obj = 1;
        } else if (SvPOK(ST(0))) {
            category = SvPVX(ST(0));
        } else {
            category = NULL;
#ifdef USE_PP_CARP
            PUSHMARK(SP);
            mXPUSHs(newSVpvs("not an object"));
            PUTBACK;
            call_pv("warnings::Croaker", G_DISCARD);
            SPAGAIN;
#else
            croak_sv(carp_shortmess(ax, newSVpvs("not an object")));
#endif
        }
    } else {
        /* when called from pp warnings::* then caller 0, else just curcop */
        const PERL_CONTEXT *cx = caller_cx(0, NULL);
        category = HvNAME(CopSTASH(cx ? cx->blk_oldcop : PL_curcop));
    }

    w = Perl_warnings_lookup(category, strlen(category));
    if (!w) {
        SV *msg = newSVpvs("");
        if (items > 0)
            sv_catpvf(msg, "Unknown warnings category '%s'", category);
        else
            sv_catpvf(msg, "package '%s' not registered for warnings", category);
#ifdef USE_PP_CARP
        PUSHMARK(SP);
        mXPUSHs(msg);
        PUTBACK;
        call_pv("warnings::Croaker", G_DISCARD);
        SPAGAIN;
#else
        croak_sv(carp_shortmess(ax, msg));
#endif
    }

    if (is_obj) {
        /* walk the callstack and find category */
	SV *eval = newSVpvs("my ($i, $pkg) = (2);\n"
"  while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n"
"    last unless @DB::args && $DB::args[0] =~ /^");
        sv_catpv(eval, category);
        sv_catpvs(eval, "=/;} $i");
        if (eval_sv(eval, G_SCALAR)) { SPAGAIN; i = TOPi - 2; }
        else i = 0;
#ifdef DEBUGGING
        if (DEBUG_v_TEST_)
            Perl_deb("warnings::%s is_obj => cx_depth=%d\n", sub, i);
#endif
        SvREFCNT_dec(eval);
    } else {
#ifdef USE_PP_CARP
        eval_sv(newSVpvs("require Carp;"), G_DISCARD);
        PUSHMARK(SP);
        PUTBACK;
        i = call_pv("Carp::short_error_loc", G_SCALAR);
        SPAGAIN;
        if (i)
            i = (int)TOPi;
        DEBUG_v(deb("Carp::short_error_loc: %d\n", i));
#else
        /* TODO Still buggy, off-by-one
           i = short_error_loc(); */
        i = long_error_loc();
        DEBUG_v(deb("long_error_loc: %d\n", i));
#endif
    }

    if (i == 0) /* A XS speciality */
        old_warnings = PL_curcop->cop_warnings;
    else if ((cx = caller_cx(i, NULL)))
        old_warnings = cx->blk_oldcop->cop_warnings;
    else
        old_warnings = pWARN_NONE;

    if  (old_warnings == pWARN_NONE)
        mask = newWSVpvh(WARN_NONEstring);
    else if (old_warnings == pWARN_STD && !(PL_dowarn & G_WARN_ON))
        mask = newWSVpvh(WARN_DEFAULTstring);
    else if (old_warnings == pWARN_ALL ||
             (old_warnings == pWARN_STD && (PL_dowarn & G_WARN_ON))) {
        const struct Perl_warnings *w_all = Perl_warnings_lookup("all", 3);
        mask = newWSV(w_all->bits, w_all->size);
    }
    else {
        assert(!specialWARN(old_warnings));
        mask = newSVpvn((char *) (old_warnings + 1), old_warnings[0]);
    }
#ifdef DEBUGGING
    if (DEBUG_v_TEST_) {
        SV *dsv = newSVpvn("", 80);
        Perl_deb("warnings::%s %s %d %s\n", sub, category, i,
                 pv_display( dsv, SvPVX(mask), SvCUR(mask), SvCUR(mask), 80));
        SvREFCNT_dec(dsv);
    }
#endif
    if (flags & WFATAL) {
        const char* m = SvPVX(mask);
        results_0 = IsSet(m, w->offset + WFATAL - 1);
        if (w->offset && !results_0) results_0 = IsSet(m, WFATAL - 1);
    }
    if (flags & WNORMAL) {
        const char* m = SvPVX(mask);
        results_1 = IsSet(m, w->offset + WNORMAL - 1);
        if (w->offset && !results_1) results_1 = IsSet(m, WNORMAL - 1);
    }
    SvREFCNT_dec(mask);
    /* &enabled and &fatal_enabled */
    if (!has_message)
        return results_0 ? results_0 : results_1;
    /* &warnif, and the category is neither enabled as warning nor as fatal */
    if (flags == (WNORMAL | WFATAL | WMESSAGE) && !(results_0 | results_1))
        return 0;
    if (results_0) {
#ifdef USE_PP_CARP
        PUSHMARK(SP);
        XPUSHs(message);
        PUTBACK;
        call_pv("warnings::Croaker", G_DISCARD);
        SPAGAIN;
#else
        croak_sv(carp_longmess(ax, message));
#endif
    }
    /* will always get here for &warn. will only get here for &warnif if the
       category is enabled */
#ifdef USE_PP_CARP
    {
        if (is_obj)
            eval_sv(newSVpvs("require Carp;"), G_DISCARD);
        PUSHMARK(SP);
        mXPUSHi(i);
        XPUSHs(message);
        PUTBACK;
        call_pv("Carp::ret_summary", G_SCALAR);
        SPAGAIN;
        warn_sv(TOPs);
    }
#else
    warn_sv(carp_shortmess(ax, message));
#endif
    return 1;
}

/* sv_magic_set ${^WARNINGS_BITS} = mask */
static void
_set_warn_bits(SV* mask, const char *func, const char* arg) {
#ifdef DEBUGGING
    if (DEBUG_v_TEST_) {
        SV *dsv = newSVpvn("", 80);
        Perl_deb("warnings::%s %s %s\n", func, arg,
                 pv_display( dsv, SvPVX(mask), SvCUR(mask), SvCUR(mask), 80));
        SvREFCNT_dec(dsv);
    }
#else
    PERL_UNUSED_ARG(func);
    PERL_UNUSED_ARG(arg);
#endif
    if (PL_dowarn & G_WARN_ALL_MASK) return;

    /* we always call it with a string */
    if (!SvPOK(mask)) {
        PL_compiling.cop_warnings = pWARN_STD;
        return;
    }
    if (memEQs(SvPVX(mask), WARNsize, WARN_ALLstring)) {
        if (!specialWARN(PL_compiling.cop_warnings))
            PerlMemShared_free(PL_compiling.cop_warnings);
        PL_compiling.cop_warnings = pWARN_ALL;
        PL_dowarn |= G_WARN_ONCE;
    } else if (memEQs(SvPVX(mask), WARNsize, WARN_NONEstring)) {
        if (!specialWARN(PL_compiling.cop_warnings))
            PerlMemShared_free(PL_compiling.cop_warnings);
        PL_compiling.cop_warnings = pWARN_NONE;
    } else {
        PL_compiling.cop_warnings
            = Perl_new_warnings_bitfield(aTHX_ PL_compiling.cop_warnings,
                                         SvPVX(mask), SvCUR(mask));
        if (isWARN_on(PL_compiling.cop_warnings, WARN_ONCE))
            PL_dowarn |= G_WARN_ONCE;
    }
}

static SV*
_do_bits(SV *mask, const SV * const word, int fatal, int nonfatal) {
    if (SvPOK(word)) {
        const struct Perl_warnings *w
            = Perl_warnings_lookup(SvPVX_const(word), SvCUR(word));
        if (w) {
            SV *tmp = newWSV(w->bits, w->size);
            do_vop(OP_BIT_OR, mask, mask, tmp);
            SvREFCNT_dec(tmp);
            if (fatal) {
                tmp = newWSV(w->deadbits, w->size);
                do_vop(OP_BIT_OR, mask, mask, tmp);
                SvREFCNT_dec(tmp);
            }
            if (nonfatal) {
                U8 *p;
                STRLEN j;
                SV *tmp = newWSVpvs("");
                SV *dead = newWSV(w->deadbits, w->size);
                SV *three = newWSVpvs("\3");
                do_vop(OP_BIT_OR, tmp, dead, three);
                /* scomplement is static */
                for (p=(U8*)SvPVX(tmp), j=0; j<SvCUR(tmp); j++) {
                    const U8 c = *p;
                    *p++ = ~c;
                }
                do_vop(OP_BIT_AND, mask, mask, tmp);
                SvREFCNT_dec(three);
                SvREFCNT_dec(dead);
                SvREFCNT_dec(tmp);
            }
            return mask;
        } else {
#ifdef USE_PP_CARP
            dSP;
#else
            dORIGMARK;
            I32 ax = TOPMARK - 1; /* ??? Test with Carp XS */
#endif
            SV *msg = newSVpvs("Unknown warnings category '");
            sv_catsv(msg, (SV * const)word);
            sv_catpvs(msg, "'");
            /* But here the fallback to pp warnings::Croaker does not work */
#ifdef USE_PP_CARP
            PUSHMARK(SP);
            mXPUSHs(msg);
            PUTBACK;
            call_pv("warnings::Croaker", G_DISCARD);
            SPAGAIN;
#else
            croak_sv(carp_shortmess(ax, msg));
#endif
            return NULL;
        }
    }
    return NULL;
}


MODULE = warnings		PACKAGE = warnings
PROTOTYPES: DISABLE

void
_bits (mask, ...)
     SV *mask
PREINIT:
    int i;
    int fatal = 0, no_fatal = 0;
PPCODE:
    if (!SvPOK(mask))
        mask = sv_2mortal(newWSVpvh(WARN_NONEstring));
    for (i=1; i<items; i++) {
        SV *word = ST(i);
        if (SvPOK(word)) {
            if (memEQs(SvPVX(word), SvCUR(word), "FATAL")) {
                fatal = 1;
                no_fatal = 0;
            } else
            if (memEQs(SvPVX(word), SvCUR(word), "NONFATAL")) {
                fatal = 0;
                no_fatal = 1;
            } else {
                mask = _do_bits(mask, word, fatal, no_fatal);
            }
        }
    }
    TOPs = mask;
    XSRETURN(1);

void
bits (...)
PPCODE:
    PUSHMARK(SP);
    mXPUSHs(&PL_sv_undef);
    if (!items)
        mXPUSHs(newSVpvs("all"));
    PUTBACK;
    if (call_pv("warnings::_bits", G_SCALAR)) {
        SPAGAIN;
        XSRETURN(1);
    } else
        XSRETURN_UNDEF;

void
import (klass, ...)
    SV* klass
PREINIT:
    SV *mask;
    struct Perl_warnings *w_all = NULL;
PPCODE:
    if (!SvPOK(klass))
        croak_xs_usage(cv,  "class, ...");
    /* mask = ${^WARNING_BITS} // ($^W ? $Bits{all} : $DEFAULT); */
    if (specialWARN(PL_compiling.cop_warnings)) {
        if (PL_dowarn & G_WARN_ON || PL_compiling.cop_warnings == pWARN_ALL) {
            w_all = Perl_warnings_lookup("all", 3);
            mask = newWSV(w_all->bits, w_all->size);
        } else if (PL_compiling.cop_warnings == pWARN_NONE) {
            mask = newWSVpvh(WARN_NONEstring);
        } else {
            mask = newWSVpvh(WARN_DEFAULTstring);
        }
    } else
        mask = newSVpvn((char*)((STRLEN*)PL_compiling.cop_warnings+1),
                        *PL_compiling.cop_warnings);

    if (IsSet(SvPVX(mask), 0)) {
        SV* tmp;
        if (!w_all) w_all = Perl_warnings_lookup("all", 3);
        tmp = newWSV(w_all->bits, w_all->size);
        do_vop(OP_BIT_OR, mask, mask, tmp);
        SvREFCNT_dec(tmp);
        if (IsSet(SvPVX(mask), 1)) {
            tmp = newWSV(w_all->deadbits, w_all->size);
            do_vop(OP_BIT_OR, mask, mask, tmp);
            SvREFCNT_dec(tmp);
        }
    }
    if (items > 1) {
        int i;
        SV *word;
        int fatal = 0, no_fatal = 0;
        for (i=1; i<items; i++) {
            word = ST(i);
            if (SvPOK(word)) {
                if (memEQs(SvPVX(word), SvCUR(word), "FATAL")) {
                    fatal = 1;
                    no_fatal = 0;
                }
                else if (memEQs(SvPVX(word), SvCUR(word), "NONFATAL")) {
                    fatal = 0;
                    no_fatal = 1;
                } else {
                    mask = _do_bits(mask, word, fatal, no_fatal);
                }
            }
        }
        word = ST(1);
        /* push @_, 'all' if @_==1 && ( $_[0] eq 'FATAL' || $_[0] eq 'NONFATAL' ); */
        if (items == 2 && SvPOK(word)) {
            SV* all = newSVpvs("all");
            if (memEQs(SvPVX(word), SvCUR(word), "FATAL"))
                mask = _do_bits(mask, all, 1, 0);
            else if (memEQs(SvPVX(word), SvCUR(word), "NONFATAL"))
                mask = _do_bits(mask, all, 0, 1);
            SvREFCNT_dec(all);
        }
        _set_warn_bits(mask, "import", SvPVX(word));
        SvREFCNT_dec(mask);
        XSRETURN_UNDEF;
    } else {
        SV *tmp;
        if (!w_all) w_all = Perl_warnings_lookup("all", 3);
        tmp = newWSV(w_all->bits, w_all->size);
        do_vop(OP_BIT_OR, mask, mask, tmp);
        SvREFCNT_dec(tmp);
        _set_warn_bits(mask, "import", "");
        mXPUSHs(mask);
        XSRETURN(1);
    }

void
unimport (klass, ...)
   SV* klass
PREINIT:
    SV *mask;
    int i;
    struct Perl_warnings *w_all = NULL;
PPCODE:
    if (!SvPOK(klass))
        croak_xs_usage(cv,  "class, ...");
    /* mask = ${^WARNING_BITS} // ($^W ? $Bits{all} : $DEFAULT); */
    if (specialWARN(PL_compiling.cop_warnings)) {
        if (PL_dowarn & G_WARN_ON || PL_compiling.cop_warnings == pWARN_ALL) {
            w_all = Perl_warnings_lookup("all", 3);
            mask = newWSV(w_all->bits, w_all->size);
        } else if (PL_compiling.cop_warnings == pWARN_NONE) {
            mask = newWSVpvh(WARN_NONEstring);
        } else {
            mask = newWSVpvh(WARN_DEFAULTstring);
        }
    } else
        mask = newSVpvn((char*)((STRLEN*)PL_compiling.cop_warnings+1),
                        *PL_compiling.cop_warnings);

    if (IsSet(SvPVX(mask), 0)) {
        SV *tmp;
        if (!w_all) w_all = Perl_warnings_lookup("all", 3);
        tmp = newWSV(w_all->bits, w_all->size);
        do_vop(OP_BIT_OR, mask, mask, tmp);
        SvREFCNT_dec(tmp);
        if (IsSet(SvPVX(mask), 1)) {
            tmp = newWSV(w_all->deadbits, w_all->size);
            do_vop(OP_BIT_OR, mask, mask, tmp);
            SvREFCNT_dec(tmp);
        }
    }
    /* push @_, 'all' if !@_ || @_==1 && $_[0] eq 'FATAL'; */
    if ((items == 1) ||
        (items == 2 && (SvPOK(ST(1)) && memEQs(SvPVX(ST(1)), SvCUR(ST(1)), "FATAL"))))
    {
        mPUSHs(newSVpvs("all"));
        ax--;
        items++;
    }
    for (i=1; i<items; i++) {
        SV *word = ST(i);
        if (!SvPOK(word)) continue;
        if (memEQs(SvPVX(word), SvCUR(word), "FATAL"))
            continue;
        else {
            const struct Perl_warnings *w
                = Perl_warnings_lookup(SvPVX(word), SvCUR(word));
            if (w) { /* $mask &= ~($catmask | $DeadBits{$word} | $All); */
                STRLEN j; U8 *p;
                SV *catmask = newWSV(w->bits, w->size);
                SV *dead    = newWSV(w->deadbits, w->size);
                SV *three   = newWSVpvs("\3");
                do_vop(OP_BIT_OR, catmask, catmask, dead);
                do_vop(OP_BIT_OR, catmask, catmask, three); /* $All */
                for (p=(U8*)SvPVX(catmask), j=0; j<SvCUR(catmask); j++) {
                    const U8 c = *p;
                    *p++ = ~c;
                }
                do_vop(OP_BIT_AND, mask, mask, catmask);
                SvREFCNT_dec(three);
                SvREFCNT_dec(dead);
                SvREFCNT_dec(catmask);
            } else {
                SV *msg = newSVpvs("Unknown warnings category '");
                sv_catsv(msg, word);
                sv_catpvs(msg, "'");
#ifdef USE_PP_CARP
                PUSHMARK(SP);
                mXPUSHs(msg);
                PUTBACK;
                call_pv("warnings::Croaker", G_DISCARD);
                SPAGAIN;
#else
                croak_sv(carp_shortmess(ax, msg));
#endif
            }
        }
    }
    _set_warn_bits(mask, "unimport", items > 1 ? SvPVX(ST(1)) : "");
    mXPUSHs(mask);
    XSRETURN(1);

void
_chk (SV *sub, IV flags, ...)
PPCODE:
    if (_chk(SvPVX(sub), flags, ax+2))
        XSRETURN_YES;
    else
        XSRETURN_NO;

#if 0

void
enabled (...)
PPCODE:
    if (_chk("enabled", WNORMAL, ax))
        XSRETURN_YES;
    else
        XSRETURN_NO;

void
fatal_enabled (...)
PPCODE:
    if (_chk("fatal_enabled", WFATAL, ax))
        XSRETURN_YES;
    else
        XSRETURN_NO;

void
warn (...)
PPCODE:
    if (_chk("warn", WFATAL|WMESSAGE, ax))
        XSRETURN_YES;
    else
        XSRETURN_NO;

void
warnif (...)
PPCODE:
    if (_chk("warnif", WNORMAL|WFATAL|WMESSAGE, ax))
        XSRETURN_YES;
    else
        XSRETURN_NO;

#endif

void
register_categories (...)
PREINIT:
    int i;
PPCODE:
    /* check if name is registered (const key).
       if not, add key and also add bit to Bits{all} and DeadBits{all} */
    for (i=0; i<items; i++) {
        SV *name = ST(i);
        char* n;
        struct Perl_warnings *w;
        STRLEN l = SvCUR(name);
        if (!SvPOK(name)) continue;
        n = SvPVX(name);
        w = Perl_warnings_lookup(n, l);
        if (!w) { /* oops, a new category. Add to dynamic %_Bits */
            struct Perl_warnings_dyn* wd = NULL;
            HV * const bith = get_hv("warnings::_Bits", GV_ADD);
            SV *last_bitsv  = get_sv("warnings::LAST_BIT", 0);
            IV last_bit = SvIVX(last_bitsv);
            IV offset = last_bit + 1;
            SV *bytes = get_sv("warnings::BYTES", 0);
            SV *bits = newWSVpvs("");
            SV *dead = newWSVpvs("");
            U32 nl = SvIVX(bytes);
            char *b, *d;

            /* with elements in %_Bits its guaranteed to return a dynamic wd,
               otherwise the static w, which will ignore from now on */
            if (HvTOTALKEYS(bith)) {
                wd = (struct Perl_warnings_dyn *)Perl_warnings_lookup("all", 3);
            }
            
            SvGROW(bits, nl*2);
            SvGROW(dead, nl);
            SvCUR_set(bits, nl);
            SvCUR_set(dead, nl);
            b = SvPVX(bits);
            d = SvPVX(dead);
            b[ Off(last_bit) ] |= Bit(last_bit);
            d[ Off(offset) ]   |= Bit(offset);
            sv_catsv(bits, dead);
            sv_upgrade(bits, SVt_PVIV);
            SvIV_set(bits, last_bit);
            SvREADONLY_off(bith);
            hv_store_ent(bith, name, bits, 0);
#ifdef DEBUGGING
            if (DEBUG_v_TEST_) {
                SV *dsv = newSVpvn("", 80);
                Perl_deb("warnings::register_categories %s %s\n", n,
                         pv_display( dsv, SvPVX(bits), SvCUR(bits), WARN_MAX_BYTES, 80));
                SvREFCNT_dec(dsv);
            }
#endif
            /* also extend "all" */
            if (!wd) { /* fresh */
                bits = newWSVpvs("");
                SvGROW(bits, nl*2);
                Move(WARN_ALLstring, SvPVX_const(bits), nl, char);
                Move(WARN_DEADALLstring, SvPVX_const(dead), nl, char);
                SvCUR_set(bits, nl);
                b = SvPVX(bits);
                d = SvPVX(dead);
                b[ Off(last_bit) ] |= Bit(last_bit);
                d[ Off(offset) ]   |= Bit(offset);
                sv_catsv(bits, dead);
                sv_upgrade(bits, SVt_PVIV);
                SvIV_set(bits, 0);
                hv_store(bith, "all", 3, bits, 0);
            } else { /* existing $_Bits{all} */
                U32 l = SvCUR(wd->base) / 2;
                bits = wd->base;
                if (nl > l) {
                    SvGROW(bits, nl*2);
                    SvCUR_set(bits, nl);
                    wd->bits = SvPVX(bits);
                    Move(wd->deadbits, wd->bits + l, nl, char);
                    wd->deadbits = wd->bits + nl;
                }
                wd->bits[   Off(last_bit) ] |= Bit(last_bit);
                wd->deadbits[ Off(offset) ] |= Bit(offset);
            }
            SvREADONLY_on(bith);

            last_bit = offset + 1;
            if (Off(last_bit) > SvIVX(bytes)) {
                SvREADONLY_off(bytes);
                SvIV_set(bytes, Off(last_bit));
                SvREADONLY_on(bytes);
            }
            SvREADONLY_off(last_bitsv);
            SvIV_set(last_bitsv, last_bit);
            SvREADONLY_on(last_bitsv);
            SvREFCNT_dec(dead);
#ifdef DEBUGGING
            if (DEBUG_v_TEST_) {
                SV *dsv = newSVpvn("", 80);
                Perl_deb(" all=%s, BYTES=%ld, LAST_BIT=%ld\n",
                         pv_display( dsv, SvPVX(bits), SvCUR(bits), WARN_MAX_BYTES, 80),
                         SvIVX(bytes), last_bit);
                SvREFCNT_dec(dsv);
            }
#endif
            /* Do we need to update ${^WARNING_BITS}/cop_warnings also? */
            /* _set_warn_bits(newWSV(wd->bits, SvIVX(bytes)), "register_categories", n); */
        }
    }
    XSRETURN_UNDEF;

void
KEYS()
PREINIT:
    int i;
    const int size = TOTAL_KEYWORDS;
    char *s = (char *)stringpool;
    HV * const bits = get_hv("warnings::_Bits", 0);
PPCODE:
    /* Note: This is highly gperf dependent! */
    EXTEND(sp, size);
    for (i=0; i<size; i++) {
        int l = strlen(s);
        mPUSHp(s, l);
        s += l+1;
    }
    if (bits) {
        I32 len = HvTOTALKEYS(bits);
        EXTEND(sp, len);
        /* And now the dynamic bits */
        hv_iterinit(bits);
        for (i = 0; i < len; i++) {
            HE *he = hv_iternext(bits);
            SV *key = hv_iterkeysv(he);
            if (strnNE(SvPVX(key), "all", SvCUR(key)))
                PUSHs(key);
        }
    }

# in fact a HASHOBJ*
void
TIEHASH(classname)
    SV * classname
PREINIT:
    SV * rv;
    SV * tmp;
CODE:
    rv = sv_newmortal();
    tmp = classname;
    *SP = rv;
    sv_setref_uv(rv, SvPVX(tmp), 0);
    return;

void
FIRSTKEY(self)
    HASHOBJ *self
PREINIT:
    const char *s = (const char *)stringpool;
    size_t len;
    STATIC_ASSERT_STMT(sizeof(stringpool_contents) > 1);
CODE:
    len = strlen(s);
    *self = len + 1;
    *SP = sv_2mortal(newSVpvn(aTHX_ s, len));
    return;

void
NEXTKEY(self, lastkey)
    HASHOBJ *self
    SV *lastkey
PREINIT:
    SV * RETVAL;
PPCODE:
    PERL_UNUSED_VAR(lastkey);
    SP++;
    PUTBACK;
    /* bounds check to avoid running off the end of stringpool */
    if (*self < sizeof(stringpool_contents)) {
        const char * key = (const char*)stringpool + *self;
        size_t len = strlen(key);
        *self += len + 1;
        RETVAL = sv_2mortal(newSVpvn(aTHX_ key, len));
    }
    else
        RETVAL = &PL_sv_undef;
    *SP = RETVAL;
    return;

void
FETCH(self, category)
    SV* self
    SV* category
ALIAS:
    EXISTS = 1
PREINIT:
    const char *str = SvPVX(category);
    const IV len = SvCUR(category);
    const struct Perl_warnings *w = warnings_const_lookup(str, len);
    const char* name = HvNAME(SvSTASH(SvRV(self)));
    const bool isdead = name && strEQ(name, "warnings::_DeadBits");
PPCODE:
    if (w) {
        if (ix)
            XSRETURN_YES;
        else {
            ST(0) = sv_2mortal(newWSV(isdead ? w->deadbits : w->bits, w->size));
            XSRETURN(1);
        }
    } else {
        SV **bit;
        HV * const bits = get_hv("warnings::_Bits", 0);
        if (bits) {
            SvREADONLY_off(bits);
            if ((bit = hv_fetch(bits, str, len, FALSE))) {
                SvREADONLY_on(bits);
                if (ix)
                    XSRETURN_YES;
                else {
                    STRLEN len = SvCUR(*bit);
                    ST(0) = sv_2mortal(newSVpvn(SvPVX_const(*bit)+(isdead ? len/2 : 0),
                                                len/2));
                    XSRETURN(1);
                }
            }
            SvREADONLY_on(bits);
        }
    }
    XSRETURN_UNDEF;

BOOT:
{
    GV *last_bit = gv_fetchpv("warnings::LAST_BIT", GV_ADDMULTI, SVt_IV);
    GV *bytes    = gv_fetchpv("warnings::BYTES", GV_ADDMULTI, SVt_IV);
    GvSV(last_bit) = newSViv(WARN_LAST_BIT);
    SvREADONLY_on(GvSV(last_bit));
    GvSV(bytes)    = newSViv(WARNsize);
    SvREADONLY_on(GvSV(bytes));
}
