{"version":1,"ops":[{"type":1,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1478859031,"metadata":{"github-id":"MDU6SXNzdWUxODg3MjY3MzA=","github-url":"https://github.com/perl11/cperl/issues/220","origin":"github"},"title":"tracing jit","message":"The jit will be a tracing jit, not a method jit.\nA tracing jit is slower, much more complex and needs more profiling state, \nbut needs much less memory, esp. on such dynamic apps with lot of dead code never executed.\nWe want to trace calls and loops, similar to v8. For us memory is more important than performance.\nA perl5 jit has not much benefits, as the ops are way too dynamic, so we mostly just win with the icache, having the op calls aligned one after another in memory, and not jumping to random heap locations. With more and more type information a real jit, going into the ops would be worthwhile. e.g. for typed native arrays or native arith.\n\ndynasm is currently the easiest, as it allows more archs, moar already uses it. But you have to write your insn manually, not abstract as in libjit or asmjit. but it supports other more important abstraction, like types and slots, ...\none nice thing would be to replace the dynasm.lua preprocessor with a simple perl script. this would need max 2 days.\n\nSee e.g. https://github.com/imasahiro/rujit/ for a memory hungry tracing jit, 2-3x faster.\nWe will always have the fallback to use the huge llvm jit, but I'm sceptical that it's fast enough with its overhead. Testing it at first, as `libcperl.bc` can be imported and used for LTO and inlining.\nThe experimental guile tracing jit nash looks better: https://github.com/8c6794b6/guile-tjit-documentation/blob/master/nash.pdf\n\nWe also need the jit for the ffi, so we can omit libffi, and just go with the jit.","files":null}]}