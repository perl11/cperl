use Config;
our $VERSION = "2.00c";

sub to_string {
    my ($value) = @_;
    $value =~ s/\\/\\\\/g;
    $value =~ s/'/\\'/g;
    return "'$value'";
}
sub to_dqstring {
    my ($value) = @_;
    $value =~ s/\\/\\\\/g;
    $value =~ s/"/\\"/g;
    return "\"$value\"";
}

# symlinks are currently also resolved.
# e.g.
#    ("/usr/lib", "/lib/x86_64-linux-gnu", "/lib/../lib", "/usr/lib/x86_64-linux-gnu", "/usr/lib/../lib")
# => ("/usr/lib", "/lib/x86_64-linux-gnu", "/lib", "/usr/lib/x86_64-linux-gnu")
sub resolve_duplicate_paths {
    # first resolve w/../w => w
    foreach (@_) {
        s{(\w+)/\.\./$1$}{$1};
    }
    # then remove duplicates, but keep order intact
    my %p = ();
    my @out = ();
    foreach (@_) {
        unless (exists $p{$_}) {
            if (-l $_ && -e readlink $_) {
                $_ = readlink $_;
            }
            if (-e $_) {
                push @out, $_;
                $p{$_} = 1;
            }
        }
    }
    @out
}

sub line_prefix {
    my $line = shift;
    $line++;
    return "#line $line \"dlboot_c.PL\"\n" . shift;
}

unlink "dlboot.c" if -f "dlboot.c";
open OUT, ">dlboot.c" or die $!;

my $ldlibpthname_defined = defined $Config{ldlibpthname};

print OUT line_prefix(__LINE__, <<'EOT');
/* ex: set ro ft=c: -*- buffer-read-only:t -*-
 * !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
 * Any changes made here will be lost
 * Generated from dlboot_c.PL
 *
 * Copyright (C) 2015 cPanel Inc
 * Licensed under the same terms as Perl itself.
 */

<<<<<<<
/* DynaLoader globals */
SV *do_expand;               /* if to call dl_expandspec hook */
/* dl_debug;                 -- IV from $ENV{PERL_DL_DEBUG}, stored in CTX */
=======
static const char file[] = __FILE__;
/* 1 on VMS */
#define DL_DO_EXPAND <<$^O-eq-VMS>>1<<|$^O-eq-VMS>>0<</$^O-eq-VMS>>
SV *do_expand;
AV *dl_require_symbols;      /* names of symbols we need */
AV *dl_resolve_using;        /* names of files to link with */
AV *dl_library_path;         /* path to look for files */

#define AV_PUSH(av, val) av_store(av, AvFILLp(av)+1, val)
EOT
die "Invalid \$Config{path_sep}" unless $Config{path_sep};
print OUT <<"EOT";
const char dl_ext[] = "$Config{dlext}";
const char dl_so[]  = "$Config{so}";
const char dl_src[] = "$Config{dlsrc}";
const char pthsep[] = "$Config{path_sep}";
>>>>>>>

<<<<<<<
#define AV_PUSH(av, val) av_store(av, AvFILLp(av)+1, val)

#ifdef VMS
#  define DL_DO_EXPAND 1
#else
#  define DL_DO_EXPAND 0
#endif
static const char file[]  = __FILE__;
static const char utilsfile[]  = "dsutils.c";
static const char xsloaderfile[]  = "XSLoader.c";
const char pthsep[]       = PATH_SEP;
const char ldlibpthname[] = LDLIBPTHNAME;

static SV * dl_findfile(pTHX_ AV* args, int gimme);
=======
EOT
print OUT <<'EOT';
static SV * dl_findfile(pTHX_ AV* args, int gimme);
>>>>>>>
static char * av_tostr(pTHX_ AV *args);
<<<<<<<
PERL_CALLCONV void XS_DynaLoader_bootstrap_inherit(pTHX_ CV *cv);
PERL_CALLCONV void XS_DynaLoader_bootstrap(pTHX_ CV *cv);
PERL_CALLCONV void XS_DynaLoader_dl_findfile(pTHX_ CV *cv);
#ifndef VMS
PERL_CALLCONV void XS_DynaLoader_dl_expandspec(pTHX_ CV *cv);
#endif
PERL_CALLCONV void XS_DynaLoader_dl_find_symbol_anywhere(pTHX_ CV *cv);
#ifdef HAS_LIBNAME_UNIQUE
PERL_CALLCONV void XS_DynaLoader_mod2fname(pTHX_ CV *cv);
#endif
PERL_CALLCONV void XS_XSLoader_load(pTHX_ CV *cv);
PERL_CALLCONV void XS_XSLoader_load_file(pTHX_ CV *cv);
PERL_CALLCONV void XS_XSLoader_bootstrap_inherit(pTHX_ CV *cv);

=======
PERL_XS_EXPORT_C void XS_DynaLoader_bootstrap_inherit(pTHX_ CV *cv);
PERL_XS_EXPORT_C void XS_DynaLoader_bootstrap(pTHX_ CV *cv);
PERL_XS_EXPORT_C void XS_DynaLoader_dl_findfile(pTHX_ CV *cv);
PERL_XS_EXPORT_C void XS_DynaLoader_dl_expandspec(pTHX_ CV *cv);
PERL_XS_EXPORT_C void XS_DynaLoader_dl_find_symbol_anywhere(pTHX_ CV *cv);
EOT
if ( $Config::Config{d_libname_unique} ) {
    print OUT <<'EOT';
PERL_XS_EXPORT_C void XS_DynaLoader_mod2fname(pTHX_ CV *cv);
EOT
}
print OUT <<'EOT';
>>>>>>>
EXTERN_C void
dl_boot (pTHX) {
    dSP;
    char *env;
#ifdef DEBUGGING
    const char *debug = PerlEnv_getenv("PERL_DL_DEBUG");
    UV tmp_dl_debug;
#endif
    HV * dl_stash = get_hv("main::DynaLoader::", GV_ADDMULTI);
    newCONSTSUB( dl_stash, "dl_load_flags", newSViv(0) );
#ifdef DEBUGGING
    /* enable debug/trace messages from DynaLoader perl code */
    if (debug && *debug
       && (grok_number(debug, strlen(debug), &tmp_dl_debug) & IS_NUMBER_IN_UV)
       && tmp_dl_debug <= INT_MAX)
    {
        SV *sv = get_sv("DynaLoader::dl_debug", GV_ADDMULTI);
        sv_upgrade(sv, SVt_IV);
        SvIV_set(sv, tmp_dl_debug);
        dl_debug = (int)tmp_dl_debug;
    }
#endif
    do_expand = get_sv("DynaLoader::dl_expand", GV_ADDMULTI);
    if (SvTYPE(do_expand) < SVt_IV || !SvIOK(do_expand)) {
        sv_upgrade(do_expand, SVt_IV);
        SvIV_set(do_expand, DL_DO_EXPAND);
    }
    dl_library_path = get_av("DynaLoader::dl_library_path", GV_ADDMULTI);
    (void)hv_store(GvHVn(PL_incgv), "DynaLoader.pm", sizeof("DynaLoader.pm")-1,
                   SvREFCNT_inc_simple_NN(newSVpv_share(__FILE__, 0)), 0);
EOT
my $NUMVER = 0+$VERSION;
print OUT line_prefix(__LINE__, <<"EOT");
    Perl_set_version(aTHX_ STR_WITH_LEN("DynaLoader::VERSION"), STR_WITH_LEN("$VERSION"), $NUMVER);
EOT
print OUT line_prefix(__LINE__, <<'EOT');
    newXS("DynaLoader::bootstrap_inherit", XS_DynaLoader_bootstrap_inherit, utilsfile);
    newXS("DynaLoader::bootstrap",         XS_DynaLoader_bootstrap, utilsfile);
    newXS("DynaLoader::dl_findfile",       XS_DynaLoader_dl_findfile, utilsfile);
#ifndef VMS
    newXS("DynaLoader::dl_expandspec",     XS_DynaLoader_dl_expandspec, utilsfile);
#endif
    newXS("DynaLoader::dl_find_symbol_anywhere", XS_DynaLoader_dl_find_symbol_anywhere, utilsfile);
#ifdef HAS_LIBNAME_UNIQUE
    newXS("DynaLoader::mod2fname", 	   XS_DynaLoader_mod2fname, utilsfile);
#endif

<<<<<<<
    newXS("DynaLoader::bootstrap_inherit", XS_DynaLoader_bootstrap_inherit, file);
    newXS("DynaLoader::bootstrap",         XS_DynaLoader_bootstrap, file);
    newXS("DynaLoader::dl_findfile",       XS_DynaLoader_dl_findfile, file);
    newXS("DynaLoader::dl_expandspec",     XS_DynaLoader_dl_expandspec, file);
    newXS("DynaLoader::dl_find_symbol_anywhere", XS_DynaLoader_dl_find_symbol_anywhere, file);
EOT
if ( $Config::Config{d_libname_unique} ) {
  print OUT <<'EOT';
    newXS("DynaLoader::mod2fname", 	   XS_DynaLoader_mod2fname, file);
EOT
}
print OUT <<'EOT' if $Config{dlsrc} eq "dl_dld.xs";
=======
    newXS("XSLoader::load",                XS_XSLoader_load, xsloaderfile);
    newXS("XSLoader::load_file",           XS_XSLoader_load_file, xsloaderfile);
    newXS("XSLoader::bootstrap_inherit",   XS_XSLoader_bootstrap_inherit, xsloaderfile);
    /* TODO CM-604: broke t/comp/require.t test 53: require does not localise %^H at run time */
    Perl_set_version(aTHX_ STR_WITH_LEN("XSLoader::VERSION"), STR_WITH_LEN("1.00c"), 1.00);
    (void)hv_store(GvHVn(PL_incgv), "XSLoader.pm", sizeof("XSLoader.pm")-1,
                   newSVpvs("XSLoader.c"), 0);
>>>>>>>

<<<<<<<
    /* This is a fix to support DLD's unfortunate desire to relink -lc */
    dl_resolve_using = get_av("DynaLoader::dl_resolve_using", GV_ADDMULTI);
    {
        SV *sv = dl_findfile(aTHX_ av_store(dl_resolve_using, 0, newSVpvs("-lc")), G_SCALAR);
        if (sv)
            AV_PUSH(dl_resolve_using, sv);
    }
=======
    /* with duplicates removed and symlinks resolved from $Config{libpth} */
>>>>>>>
EOT

# resolve duplicates at least here, if Configure is not up to the task
# TODO: Do this in Configure, put this into config.h to get rid of miniperl.
# This is the only non-trivial part to get rid of miniperl.
for my $pth (resolve_duplicate_paths(split(' ', $Config{libpth}))) {
  $pth = to_dqstring($pth);
  print OUT <<"EOT";
    AV_PUSH(dl_library_path, newSVpvs($pth));
EOT
}

<<<<<<<
    if ((env = getenv(\"$Config{ldlibpthname}\")) != NULL) {
        char *cur = env;
        for (; *env; cur++) {
            if (*cur == *pthsep || !*cur) {
                AV_PUSH(dl_library_path, newSVpvn(env, cur-env));
                if (!*cur) break;
                env = cur + 1;
=======
print OUT line_prefix(__LINE__, <<'EOT');
#ifdef PATH_SEP
    if (*ldlibpthname) {
        if ((env = getenv(LDLIBPTHNAME)) != NULL) {
            char *cur = env;
            for (; *env; cur++) {
                if (*cur == *pthsep || !*cur) {
                    AV_PUSH(dl_library_path, newSVpvn(env, cur-env));
                    if (!*cur) break;
                    env = cur + 1;
                }
>>>>>>>
            }
        }
<<<<<<<
        /* E.g. HP-UX supports both its native SHLIB_PATH *and* LD_LIBRARY_PATH. */
        /* Not so sure about LIBPATH, but just add it. This is the original logic. */
        if (strNE(ldlibpthname,"LD_LIBRARY_PATH") && (env = getenv("LD_LIBRARY_PATH")) != NULL) {
            char *cur = env;
            for (; *env; cur++) {
                if (*cur == *pthsep || !*cur) {
                    AV_PUSH(dl_library_path, newSVpvn(env, cur-env));
                    if (!*cur) break;
                    env = cur + 1;
                }
=======
    }
EOT
}
if ($ldlibpthname_defined and $Config{ldlibpthname} ne 'LD_LIBRARY_PATH' and $Config{path_sep}) {
  print OUT <<'EOT';
    /* E.g. HP-UX supports both its native SHLIB_PATH *and* LD_LIBRARY_PATH. */
    if ((env = getenv("LD_LIBRARY_PATH")) != NULL) {
        char *cur = env;
        for (; *env; cur++) {
            if (*cur == *pthsep || !*cur) {
                AV_PUSH(dl_library_path, newSVpvn(env, cur-env));
                if (!*cur) break;
                env = cur + 1;
>>>>>>>
            }
        }
    }
#endif

    /* No prizes for guessing why we don't say 'bootstrap DynaLoader;' here.
       NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB */
    if (get_cv("DynaLoader::boot_DynaLoader", 0) && !get_cv("DynaLoader::dl_error", 0)) {
        PUSHMARK(SP);
        XPUSHs(newSVpvs("DynaLoader"));
        PUTBACK;
        call_pv("boot_DynaLoader", G_DISCARD);
        /* SP = PL_stack_base + POPMARK; */
    }
#ifdef DEBUGGING
    if (dl_debug) {
<<<<<<<
        PerlIO_printf(Perl_debug_log, "DynaLoader.pm loaded (%s %s)\n",
                      av_tostr(aTHX_ GvAV(PL_incgv)), av_tostr(aTHX_ dl_library_path));
        if (!get_cv("DynaLoader::boot_DynaLoader", 0))
=======
        PerlIO_printf(Perl_debug_log, "DynaLoader.pm loaded (%s, %s)\n",
                      av_tostr(aTHX_ GvAVn(PL_incgv)), av_tostr(aTHX_ dl_library_path));
        if (!get_cv("boot_DynaLoader", 0))
>>>>>>>
            PerlIO_printf(Perl_debug_log, "DynaLoader not linked into this perl\n");
    }
<<<<<<<
=======
}

XS(XS_DynaLoader_bootstrap_inherit)
{
    dXSARGS;
    AV* isa;
    if (items < 1 || !SvPOK(SP[0]))
      Perl_die(aTHX_ "Usage: DynaLoader::bootstrap_inherit(module)\n");
    ENTER_with_name("bootstrap");
    SAVETMPS;
    {
        SV *module = newSVpvn(SvPVX(SP[0]), SvCUR(SP[0]));
        sv_catpvs(module, "::ISA");
        isa = get_av(SvPVX(module), 0);
        SAVESPTR(isa);
        AV_PUSH(isa, newSVpvs("DynaLoader"));
        call_pv("DynaLoader::bootstrap", G_DISCARD);
    }
    FREETMPS;
    LEAVE_with_name("bootstrap");
    XSRETURN_EMPTY;
}
XS(XS_DynaLoader_bootstrap)
{
    dXSARGS;
    U32 i, flags = 0;
    char *modulename;
    CV *dl_load_file;
    CV *mod2fname;
    AV *modparts, *dirs;
    SV *module, *modfname, *modpname, *file, *bootname, *libref, *boot_symbol_ref;
    SV *xs, *flagsiv;

    if (items < 1 || !SvPOK(SP[0]))
      Perl_die(aTHX_ "Usage: DynaLoader::bootstrap(module)\n");
    dl_load_file = get_cv("DynaLoader::dl_load_file", 0);
    module = SP[0];
    modulename = SvPVX(module);
    if (!dl_load_file) {
      Perl_die(aTHX_ "Can't load module %s, dynamic loading not available in this perl.\n"
               "  (You may need to build a new perl executable which either supports\n"
               "  dynamic loading or has the %s module statically linked into it.)\n",
               modulename, modulename);
    }
    dl_require_symbols = get_av("DynaLoader::dl_require_symbols", GV_ADDMULTI);
EOT
print OUT <<'EOT' if $^O eq 'os2';
    if (!SvTRUE_NN(get_sv("OS2::is_static")))
        Perl_die(aTHX_ "Dynaloaded Perl modules are not available in this build of Perl");
EOT

# now start splitting and walking modparts /::/ (no utf8 yet)
print OUT <<'EOT';
    modparts = newAV();
    {
        char *mn = SvPVX(module);
        char *cur = mn;
        for (; *mn; cur++) {
            if (!*cur || (*cur == ':' && *(cur-1) == ':')) {
                AV_PUSH(modparts, newSVpvn(mn, cur-mn));
                if (!*cur) break;
                mn = cur + 1;
            }
        }
    }
    modfname = AvARRAY(modparts)[AvFILLp(modparts)];

    /* Some systems have restrictions on files names for DLL's etc.
       mod2fname returns appropriate file base name (typically truncated).
       It may also edit @modparts if required. */
    mod2fname = get_cv("DynaLoader::mod2fname", 0);
    if (mod2fname) {
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "DynaLoader: Enter mod2fname with '%s'\n", SvPVX(modfname)));
        PUSHMARK(SP);
        PUTBACK;
        XPUSHs(newRV((SV*)modparts));
        call_sv((SV*)mod2fname, G_SCALAR);
        SPAGAIN;
        modfname = POPs;
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "DynaLoader: Got mod2fname => '%s'\n", SvPVX(modfname)));
    }
EOT
print OUT <<'EOT' if $^O eq 'NetWare';
    /* Truncate the module name to 8.3 format for NetWare */
    if (SvCUR(modfname) > 8)
	SvCUR_set((modfname, 8);
EOT
print OUT <<'EOT';
    modpname = newSVpvn("", 0);
    for (i=0; i<AvFILLp(modparts)-1; i++) {
        sv_catsv(modpname, AvARRAY(modparts)[i]);
        sv_catpvs(modpname, "/");
    }
    sv_catsv(modpname, AvARRAY(modparts)[AvFILLp(modparts)]);
    DLDEBUG(1, PerlIO_printf(Perl_debug_log, "DynaLoader::bootstrap for %s "
        "(auto/%s/%s.%s)\n", modulename, SvPVX(modpname), SvPVX(modfname), dl_ext));

    dirs = newAV();
    for (i=0; i<AvFILL(GvAVn(PL_incgv)); i++) {
        SV **pdir = av_fetch(GvAVn(PL_incgv), i, 0);
        SV *dir = *pdir;
        SV *slib;
#ifdef VMS
        char *buf = tounixpath_utf8_ts(aTHX_ dir, NULL, SvUTF8(dir));
        int len = strlen(buf);
        SvGROW(dir, len);
        SvPV_set(dir, buf);
        SvCUR_set(dir, len);
#endif
        sv_catpvs(dir, "/auto/");
        sv_catsv(dir, modpname);
        {
            const char *fname = SvPV_nolen_const(dir);
            PL_laststatval = PerlLIO_stat(fname, &PL_statcache);
	    if (!S_ISDIR(PL_statcache.st_mode))
                continue;
        }

        slib = newSVpvn_flags(SvPVX(dir), SvCUR(dir), SVs_TEMP);
        sv_catpvs(slib, "/");
        sv_catsv(slib, modfname);
        sv_catpvs(slib, "/");
        sv_catpv(slib, dl_ext);
        file = NULL;

        if (do_expand) {
#ifdef VMS
            if ((file = dl_expandspec(slib)))
                break;
#endif
        }
        else {
            PL_laststatval = PerlLIO_stat(SvPVX(slib), &PL_statcache);
	    if (S_ISLNK(PL_statcache.st_mode) || S_ISREG(PL_statcache.st_mode)) {
                file = slib;
                break;
            }
        }
        av_push(dirs, dir);
    }
    if (!file) {
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "DynaLoader: @INC/auto/%s/%s.%s not found\n",
                                SvPVX(modpname), SvPVX(modfname), dl_ext));
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "DynaLoader: Searching now %s and %s\n",
                                av_tostr(aTHX_ dirs), av_tostr(aTHX_ GvAV(PL_incgv))));
        /* last resort, let dl_findfile have a go in all known locations */
        /* map("-L$_",@dirs,@INC), $modfname */
        file = dl_findfile(aTHX_ dirs, G_SCALAR);
    }
    if (!file) {
        /* wording similar to error from 'require' */
        Perl_die(aTHX_ "Can't locate loadable object for module %s in @INC (@INC contains: %s)",
                 modulename, av_tostr(aTHX_ GvAVn(PL_incgv)));
    } else {
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "DynaLoader: Found %s\n", SvPVX(file)));
    }
#ifdef VMS
    /*
    <<$^O-eq-VMS>>$file = uc($file) if $Config::Config{d_vms_case_sensitive_symbols};<</$^O-eq-VMS>>
    */
#endif

    bootname = newSVpvs("boot_");
    sv_catsv(bootname, module);
    for (i=5; i<SvCUR(bootname); i++) { /* $bootname =~ s/\W/_/g; */
        char *s = SvPVX(bootname);
        if (!isALNUMC_A(s[i]))
            s[i] = '_';
    }
    av_store(dl_require_symbols, 0, bootname);

    /* TODO .bs support, call flags method */
    flagsiv = newSViv(flags);

#ifdef DARWIN
    {
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "DynaLoader: Enter dl_find_symbol with 0, '%s'\n",
                                SvPVX(bootname)));
        PUSHMARK(SP);
        PUTBACK;
        XPUSHs(file);
        XPUSHs(flagsiv);
        call_sv((SV*)dl_find_symbol, G_SCALAR);
        SPAGAIN;
        boot_symbol_ref = POPs;
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "DynaLoader: Got boot_symbol_ref => '%p'\n", boot_symbol_ref));
        if (boot_symbol_ref)
            goto boot;
    }
#endif

    {
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "DynaLoader: Enter dl_load_file with '%s' %d\n",
                                SvPVX(file), flags));
        PUSHMARK(SP);
        PUTBACK;
        XPUSHs(file);
        XPUSHs(flagsiv);
        call_sv((SV*)dl_load_file, G_SCALAR);
        SPAGAIN;
        libref = POPs;
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "DynaLoader: Got libref => '%p'\n", libref));
    }
    if (!libref) {
        Perl_die(aTHX_ "Can't load '%s' for module %s:", file, modulename /*, dl_error()*/);
    }
    {
        AV *dl_librefs = get_av("DynaLoader::dl_librefs", GV_ADDMULTI);
        AV_PUSH(dl_librefs, libref); /* record loaded object */
    }

    /* TODO
    my @unresolved = dl_undef_symbols();
    if (@unresolved) {
	require Carp;
	Carp::carp("Undefined symbols present after loading $file: @unresolved\n");
    }
    */

    {
        CV *dl_find_symbol = get_cv("DynaLoader::dl_find_symbol", 0);
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "DynaLoader: Enter dl_find_symbol with %p %s\n",
                                libref, SvPVX(bootname)));
        PUSHMARK(SP);
        PUTBACK;
        XPUSHs(libref);
        XPUSHs(bootname);
        call_sv((SV*)dl_find_symbol, G_SCALAR);
        SPAGAIN;
        boot_symbol_ref = POPs;
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "DynaLoader: Got boot_symbol_ref => '%p'\n", boot_symbol_ref));
    }
    if (!boot_symbol_ref)
         Perl_die(aTHX_ "Can't find '%s' symbol in %s\n", SvPVX(bootname), SvPVX(file));
    {
        AV *dl_modules = get_av("DynaLoader::dl_modules", GV_ADDMULTI);
        AV_PUSH(dl_modules, module); /* record loaded module */
    }

    {
        CV *dl_install_xsub = get_cv("DynaLoader::dl_install_xsub", 0);
        SV *bootstrap = newSVpvs("");
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "DynaLoader: Enter dl_install_xsub with %s::bootstrap %p %s\n",
                                modulename, boot_symbol_ref, SvPVX(file)));
        PUSHMARK(SP);
        PUTBACK;
        sv_catsv(bootstrap, module);
        sv_catpvs(bootstrap, "::bootstrap");
        XPUSHs(boot_symbol_ref);
        XPUSHs(file);
        call_sv((SV*)dl_install_xsub, G_SCALAR);
        SPAGAIN;
        xs = POPs;
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "DynaLoader: Got %s::bootstrap => '%p'\n",
                                modulename, xs));
    }
    {
        AV *dl_shared_objects = get_av("DynaLoader::shared_objects", GV_ADDMULTI);
        AV_PUSH(dl_shared_objects, file); /* record loaded files */
    }

#ifdef DARWIN
   boot:
>>>>>>>
#endif
<<<<<<<
=======
    {
	DLDEBUG(2,PerlIO_printf(Perl_debug_log, "DynaLoader: Enter &%s::bootstrap %p\n",
                                modulename, xs));
        PUTBACK;
        call_sv(xs, GIMME);
    }
}

XS(XS_DynaLoader_dl_findfile)
{
    dXSARGS;
    AV *args = av_make(items, SP);
    SV *file = dl_findfile(aTHX_ args, GIMME);
    SP -= items;
    XPUSHs(file);
    XSRETURN(1);
}
XS(XS_DynaLoader_dl_expandspec)
{
}
XS(XS_DynaLoader_dl_find_symbol_anywhere)
{
}
EOT

if ( $Config::Config{d_libname_unique} ) {
  printf OUT <<'EOT', length($Config::Config{dlext}) + 1;
XS(XS_DynaLoader_mod2fname)
{
    dXSARGS;
    AV* parts;
    sonst int so_len = %d;
    const int name_max = 255;
    SV *libname;
    U32 i, len;

    if (items != 1 || !SvROK(ST(0)) || SvTYPE(SvRV(ST(0))) != SVt_PVAV))
        Perl_die(aTHX_ "Usage: mod2fname(\@parts)\n");
    parts = (AV*)SvRV(ST(0));
    libname = newSVpvs("PL_"):
    len = AvFILLp(parts);
    for (i=0; i<len; i++) {
      sv_catsv(libname, AvARRAY(parts)[i]);
      if (i < len-1)
      sv_catpvs(libname, "__");
    }
    if (SvCUR(libname) + so_len_ <= name_max)
        return libname;

    /* It's too darned big, so we need to go strip. We use the same
       algorithm as xsubpp does. First, strip out doubled __.
       TODO: utf8
       $libname =~ s/__/_/g; */
    for (i=1; i<SvCUR(libname); i++) {
      char *s = SvPVX(libname);
      if (s[i] == '_' && s[i-1] == '_') {
        Move(s[i], s[i-1], len-i, char);
        ((XPV*)SvANY(libname))->xpv_cur--;
      }
    }
    if (SvCUR(libname) + so_len_ <= name_max)
        return libname;
  /* TODO
    # Strip duplicate letters
    1 while $libname =~ s/(.)\1/\U$1/i;
    return $libname if (length($libname)+$so_len) <= $name_max;
  */

    SvCUR_set(libname, name_max - so_len);
    return libname;
}
EOT
}
print OUT expand_os_specific(<<'EOT');

/* Read L<DynaLoader> for detailed information.
 * This function does not automatically consider the architecture
 * or the perl library auto directories. */
static SV * dl_findfile(pTHX_ AV* args, int gimme) {
    AV* dirs;   /* which directories to search */
    AV *found;  /* full paths to real files we have found */
    U32 i;
    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_findfile(%s)\n",
                           av_tostr(aTHX_ args)));
    found = newAV();
    dirs  = newAV();

    /* accumulate directories but process files as they appear */
    for (i=0; i<AvFILLp(args); i++) {
        SV *file = AvARRAY(args)[i];
        char *fn = SvPVX(file);
        /* Special fast case: full filepath requires no search */
#ifndef VMS
        if (strchr(fn, '/')) {
            PL_laststatval = PerlLIO_stat(fn, &PL_statcache);
	    if (S_ISLNK(PL_statcache.st_mode) || S_ISREG(PL_statcache.st_mode)) {
                if (gimme != G_ARRAY) {
                    DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_findfile found (%s)\n",
                                fn));
                    return file;
                }
            }
        }
#else
        /* if (m%[:>/\]]% && -f $_) {
	    push(@found,dl_expandspec(VMS::Filespec::vmsify($_)));
	    last arg unless wantarray;
	    next;
        } */
        #error "dl_findfile: no vms support yet"
#endif
        /* Deal with directories first:
           Using a -L prefix is the preferred option (faster and more robust)
           if (m:^-L:) { s/^-L//; push(@dirs, $_); next; } */
        if (fn[0] == '-' && fn[1] == 'L') {
            Move(&fn[2], fn, SvCUR(file)-2, char);
            ((XPV*)SvANY(file))->xpv_cur--;
            AV_PUSH(dirs, file);
            continue;
        }
        /*  Otherwise we try to try to spot directories by a heuristic
            (this is a more complicated issue than it first appears)
            if (m:/: && -d $_) {   push(@dirs, $_); next; } */
        if (strchr(fn, '/')) {
            PL_laststatval = PerlLIO_stat(fn, &PL_statcache);
	    if (S_ISDIR(PL_statcache.st_mode))
                AV_PUSH(dirs, file);
        }
    }

    /*
    arg: foreach(@args) {
	<<$^O-eq-VMS>>
        # VMS: we may be using native VMS directory syntax instead of
        # Unix emulation, so check this as well
        if (/[:>\]]/ && -d $_) {   push(@dirs, $_); next; }
	<</$^O-eq-VMS>>

        #  Only files should get this far...
        my(@names, $name);    # what filenames to look for
        if (m:-l: ) {          # convert -lname to appropriate library name
            s/-l//;
            push(@names,"lib$_.$dl_so");
            push(@names,"lib$_.a");
        } else {                # Umm, a bare name. Try various alternatives:
            # these should be ordered with the most likely first
            push(@names,"$_.$dl_dlext")    unless m/\.$dl_dlext$/o;
            push(@names,"$_.$dl_so")     unless m/\.$dl_so$/o;
	    <<$^O-eq-cygwin>>
            push(@names,"cyg$_.$dl_so")  unless m:/:;
	    <</$^O-eq-cygwin>>
            push(@names,"lib$_.$dl_so")  unless m:/:;
            push(@names,"$_.a")          if !m/\.a$/ and $dlsrc eq "dl_dld.xs";
            push(@names, $_);
        }
	my $dirsep = '/';
	<<$^O-eq-symbian>>
	$dirsep = '\\';
	if ($0 =~ /^([a-z]):/i) {
	    my $drive = $1;
	    @dirs = map { "$drive:$_" } @dirs;
	    @dl_library_path = map { "$drive:$_" } @dl_library_path;
	}
	<</$^O-eq-symbian>>
        foreach $dir (@dirs, @dl_library_path) {
            next unless -d $dir;
	    <<$^O-eq-VMS>>
            chop($dir = VMS::Filespec::unixpath($dir));
	    <</$^O-eq-VMS>>
            foreach $name (@names) {
		my($file) = "$dir$dirsep$name";
                print STDERR " checking in $dir for $name\n" if $dl_debug;
		$file = ($do_expand) ? dl_expandspec($file) : (-f $file && $file);
		#$file = _check_file($file);
		if ($file) {
                    push(@found, $file);
                    next arg; # no need to look any further
                }
            }
        }
    }
    if ($dl_debug) {
        foreach(@dirs) {
            print STDERR " dl_findfile ignored non-existent directory: $_\n" unless -d $_;
        }
    }
    */

    if (gimme != G_ARRAY) {
        DLDEBUG(1,PerlIO_printf(Perl_debug_log, "dl_findfile found (%s)\n",
                                av_tostr(found)));
        return AvARRAY(found)[0];
    }
    return (SV*)found;
}

static char * av_tostr(pTHX_ AV *args) {
    int i;
    SV *pv = newSVpvs("");
    for (i=0; i<AvFILL(args); i++) {
        SV **sv = av_fetch(args, i, 0);
        if (SvPOK(*sv)) {
            sv_catsv(pv, *sv);
            sv_catpvs(pv, ", ");
        }
    }
    if (SvCUR(pv))
      SvCUR_set(pv, SvCUR(pv) - 2);
    return SvPVX(pv);
}

/*
EOT

# following long string contains $^O-specific stuff, which is factored out
print OUT expand_os_specific(<<'EOT');

sub bootstrap {
    # use local vars to enable $module.bs script to edit values
    local(@args) = @_;
    local($module) = $args[0];
    local(@dirs, $file);

    unless ($module) {
	require Carp;
	Carp::confess("Usage: DynaLoader::bootstrap(module)");
    }

    # A common error on platforms which don't support dynamic loading.
    # Since it's fatal and potentially confusing we give a detailed message.
    croak("Can't load module $module, dynamic loading not available in this perl.\n".
	"  (You may need to build a new perl executable which either supports\n".
	"  dynamic loading or has the $module module statically linked into it.)\n")
	unless defined(&dl_load_file);


    <<$^O-eq-os2>>
    # Can dynaload, but cannot dynaload Perl modules...
    die 'Dynaloaded Perl modules are not available in this build of Perl' if $OS2::is_static;

    <</$^O-eq-os2>>
    my @modparts = split(/::/,$module);
    my $modfname = $modparts[-1];

    # Some systems have restrictions on files names for DLL's etc.
    # mod2fname returns appropriate file base name (typically truncated)
    # It may also edit @modparts if required.
    $modfname = &mod2fname(\@modparts) if defined &mod2fname;

    <<$^O-eq-NetWare>>
    # Truncate the module name to 8.3 format for NetWare
	if ((length($modfname) > 8)) {
		$modfname = substr($modfname, 0, 8);
	}
    <</$^O-eq-NetWare>>

    my $modpname = join('/',@modparts);

    print STDERR "DynaLoader::bootstrap for $module ",
		       "(auto/$modpname/$modfname.$dl_dlext)\n"
	if $dl_debug;

    foreach (@INC) {
	<<$^O-eq-VMS>>chop($_ = VMS::Filespec::unixpath($_));<</$^O-eq-VMS>>
	    my $dir = "$_/auto/$modpname";
	
	next unless -d $dir; # skip over uninteresting directories
	
	# check for common cases to avoid autoload of dl_findfile
        my $try = "$dir/$modfname.$dl_dlext";
	last if $file = ($do_expand) ? dl_expandspec($try) : ((-f $try) && $try);
	
	# no luck here, save dir for possible later dl_findfile search
	push @dirs, $dir;
    }
    # last resort, let dl_findfile have a go in all known locations
    $file = dl_findfile(map("-L$_",@dirs,@INC), $modfname) unless $file;

    croak("Can't locate loadable object for module $module in \@INC (\@INC contains: @INC)")
	unless $file;	# wording similar to error from 'require'

    <<$^O-eq-VMS>>$file = uc($file) if $Config::Config{d_vms_case_sensitive_symbols};<</$^O-eq-VMS>>
    my $bootname = "boot_$module";
    $bootname =~ s/\W/_/g;
    @dl_require_symbols = ($bootname);

    # Execute optional '.bootstrap' perl script for this module.
    # The .bs file can be used to configure @dl_resolve_using etc to
    # match the needs of the individual module on this architecture.
    my $bs = $file;
    $bs =~ s/(\.\w+)?(;\d*)?$/\.bs/; # look for .bs 'beside' the library
    if (-s $bs) { # only read file if it's not empty
        print STDERR "BS: $bs ($^O, $dlsrc)\n" if $dl_debug;
        eval { do $bs; };
        warn "$bs: $@\n" if $@;
    }

    my $boot_symbol_ref;

    <<$^O-eq-darwin>>
    if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {
        goto boot; #extension library has already been loaded, e.g. darwin
    }
    <</$^O-eq-darwin>>

    # Many dynamic extension loading problems will appear to come from
    # this section of code: XYZ failed at line 123 of DynaLoader.pm.
    # Often these errors are actually occurring in the initialisation
    # C code of the extension XS file. Perl reports the error as being
    # in this perl code simply because this was the last perl code
    # it executed.

    my $flags = $module->dl_load_flags;
    <<$^O-eq-android>>
    # See the note above regarding the linker.
    $flags = 0x00;
    <</$^O-eq-android>>
    my $libref = dl_load_file($file, $flags) or
	croak("Can't load '$file' for module $module: ".dl_error());

    push(@dl_librefs,$libref);  # record loaded object

    my @unresolved = dl_undef_symbols();
    if (@unresolved) {
	require Carp;
	Carp::carp("Undefined symbols present after loading $file: @unresolved\n");
    }

    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or
         croak("Can't find '$bootname' symbol in $file\n");

    push(@dl_modules, $module); # record loaded module

  boot:
    my $xs = dl_install_xsub("${module}::bootstrap", $boot_symbol_ref, $file);

    # See comment block above

	push(@dl_shared_objects, $file); # record files loaded

    &$xs(@args);
}

sub dl_findfile {
    # Read L<DynaLoader> for detailed information.
    # This function does not automatically consider the architecture
    # or the perl library auto directories.
    my (@args) = @_;
    my (@dirs,  $dir);   # which directories to search
    my (@found);         # full paths to real files we have found
    #my $dl_ext= <<=to_string($Config::Config{'dlext'})>>; # $Config::Config{'dlext'} suffix for perl extensions
    #my $dl_so = <<=to_string($Config::Config{'so'})>>; # $Config::Config{'so'} suffix for shared libraries

    print STDERR "dl_findfile(@args)\n" if $dl_debug;

    # accumulate directories but process files as they appear
    arg: foreach(@args) {
        #  Special fast case: full filepath requires no search
	<<$^O-eq-VMS>>
        if (m%[:>/\]]% && -f $_) {
	    push(@found,dl_expandspec(VMS::Filespec::vmsify($_)));
	    last arg unless wantarray;
	    next;
        }
	<</$^O-eq-VMS>>
	<<$^O-ne-VMS>>
        if (m:/: && -f $_) {
	    push(@found,$_);
	    last arg unless wantarray;
	    next;
	}
	<</$^O-ne-VMS>>

        # Deal with directories first:
        #  Using a -L prefix is the preferred option (faster and more robust)
        if (m:^-L:) { s/^-L//; push(@dirs, $_); next; }

        #  Otherwise we try to try to spot directories by a heuristic
        #  (this is a more complicated issue than it first appears)
        if (m:/: && -d $_) {   push(@dirs, $_); next; }

	<<$^O-eq-VMS>>
        # VMS: we may be using native VMS directory syntax instead of
        # Unix emulation, so check this as well
        if (/[:>\]]/ && -d $_) {   push(@dirs, $_); next; }
	<</$^O-eq-VMS>>

        #  Only files should get this far...
        my(@names, $name);    # what filenames to look for
        if (m:-l: ) {          # convert -lname to appropriate library name
            s/-l//;
            push(@names,"lib$_.$dl_so");
            push(@names,"lib$_.a");
        } else {                # Umm, a bare name. Try various alternatives:
            # these should be ordered with the most likely first
            push(@names,"$_.$dl_dlext")    unless m/\.$dl_dlext$/o;
            push(@names,"$_.$dl_so")     unless m/\.$dl_so$/o;
	    <<$^O-eq-cygwin>>
            push(@names,"cyg$_.$dl_so")  unless m:/:;
	    <</$^O-eq-cygwin>>
            push(@names,"lib$_.$dl_so")  unless m:/:;
            push(@names,"$_.a")          if !m/\.a$/ and $dlsrc eq "dl_dld.xs";
            push(@names, $_);
        }
	my $dirsep = '/';
	<<$^O-eq-symbian>>
	$dirsep = '\\';
	if ($0 =~ /^([a-z]):/i) {
	    my $drive = $1;
	    @dirs = map { "$drive:$_" } @dirs;
	    @dl_library_path = map { "$drive:$_" } @dl_library_path;
	}
	<</$^O-eq-symbian>>
        foreach $dir (@dirs, @dl_library_path) {
            next unless -d $dir;
	    <<$^O-eq-VMS>>
            chop($dir = VMS::Filespec::unixpath($dir));
	    <</$^O-eq-VMS>>
            foreach $name (@names) {
		my($file) = "$dir$dirsep$name";
                print STDERR " checking in $dir for $name\n" if $dl_debug;
		$file = ($do_expand) ? dl_expandspec($file) : (-f $file && $file);
		#$file = _check_file($file);
		if ($file) {
                    push(@found, $file);
                    next arg; # no need to look any further
                }
            }
        }
    }
    if ($dl_debug) {
        foreach(@dirs) {
            print STDERR " dl_findfile ignored non-existent directory: $_\n" unless -d $_;
        }
        print STDERR "dl_findfile found: @found\n";
    }
    return $found[0] unless wantarray;
    @found;
>>>>>>>
}
EOT

close OUT or die $!;

