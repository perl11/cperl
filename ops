{"version":1,"ops":[{"type":6,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1606557614,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo0NjE2Mjg4MzI="},"target":"c85086326fe326401e0c7edd4d1fd8a85b077fb283eb8d2cfb19a6023967e0b9","message":"Note that the perl5 design choices for drand48() are extremely poor. (but not entirely unexpected from p5p).\n\n1st: Taking the primitive freebsd rand48() they use ldexp(.., -48)\n       to limit the result to 48 bits, not the much faster bitmasking.\n      The FreeBSD original is sane here.\n \n 2nd: Masking to 48 bits not 53 makes creating uniform double values much harder.\n       Normally you would create 64-bit numbers as with every other rng. Then\n       you have proper int ranges as well as double.\n\nUse a good one instead, which works on 32bit and 64bit systems, \nproducing full range ints and doubles, ~10x faster. e.g wyrand. \nSee https://rurban.github.io/dieharder/QUALITY.html\n\nAnd while we are here, seperate pp_rand into int and double methods. \nIt makes not much sense to produce doubles, when only int values are requested.","files":null},{"type":6,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1606557647,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo0NjE2Mjg5NDU="},"target":"c85086326fe326401e0c7edd4d1fd8a85b077fb283eb8d2cfb19a6023967e0b9","message":"Note that the perl5 design choices for drand48() are extremely poor. (but not entirely unexpected from p5p).\n\n1st: Taking the primitive freebsd rand48() they use ldexp(.., -48)\n       to limit the result to 48 bits, not the much faster bitmasking.\n      The FreeBSD original is sane here.\n \n 2nd: Masking to 48 bits not 53 makes creating uniform double values much harder.\n       Normally you would create 64-bit numbers as with every other rng. Then\n       you have proper int ranges as well as double.\n\nUse a good one instead, which works on 32bit and 64bit systems, \nproducing full range ints and doubles, ~10x faster. e.g wyrand. \nSee https://rurban.github.io/dieharder/QUALITY.html (the perl5 rng_drand48 test is still in work there)\n\nAnd while we are here, seperate pp_rand into int and double methods. \nIt makes not much sense to produce doubles, when only int values are requested.","files":null},{"type":6,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1606557807,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo0NjE2Mjk1MDI="},"target":"c85086326fe326401e0c7edd4d1fd8a85b077fb283eb8d2cfb19a6023967e0b9","message":"Note that the perl5 design choices for drand48() are extremely poor. (but not entirely unexpected from p5p).\n\n1st: Taking the primitive freebsd rand48() they use ldexp(.., -48)\n       to expand the 48 bits to a double, not the much faster bitmasking.\n      ldexp uses 5 branches and 1-2 multiplications.\n      The FreeBSD original is sane here.\n \n 2nd: Masking to 48 bits not 53 makes creating uniform double values much harder.\n       Normally you would create 64-bit numbers as with every other rng. Then\n       you have proper int ranges as well as double.\n\nUse a good one instead, which works on 32bit and 64bit systems, \nproducing full range ints and doubles, ~10x faster. e.g wyrand. \nSee https://rurban.github.io/dieharder/QUALITY.html (the perl5 rng_drand48 test is still in work there)\n\nAnd while we are here, seperate pp_rand into int and double methods. \nIt makes not much sense to produce doubles, when only int values are requested.","files":null},{"type":6,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1606557907,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo0NjE2Mjk2NjY="},"target":"c85086326fe326401e0c7edd4d1fd8a85b077fb283eb8d2cfb19a6023967e0b9","message":"Note that the perl5 design choices for drand48() are extremely poor. (but not entirely unexpected from p5p).\n\n1st: Taking the primitive freebsd rand48() they use ldexp(.., -48)\n       to expand the 48 bits to a double, not the much faster bitmasking.\n      ldexp uses 5 branches and 1-2 multiplications.\n      The FreeBSD original is sane here.\n \n 2nd: Masking to 48 bits not 53 makes creating uniform double values much harder.\n       Normally you would create 64-bit numbers as with every other rng. Then\n       you have proper int ranges as well as double.\n\nUse a good one instead, which works on 32bit and 64bit systems, \nproducing full range ints and doubles, ~10x faster. e.g wyrand. \nSee https://rurban.github.io/dieharder/QUALITY.html (the perl5 rng_drand48 test is still in work there)\n\nAnd while we are here, seperate pp_rand into int and double methods. \nIt makes not much sense to produce costly doubles, when only int values are requested.","files":null},{"type":6,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1606726981,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo0NjIwMDkyNzA="},"target":"c85086326fe326401e0c7edd4d1fd8a85b077fb283eb8d2cfb19a6023967e0b9","message":"Note that the perl5 design choices for drand48() are extremely poor. (but not entirely unexpected from p5p).\n\n1st: Taking the primitive freebsd rand48() they use ldexp(.., -48)\n       to expand the 48 bits to a double, not the much faster bitmasking.\n      ldexp uses 5 branches and 1-2 multiplications.\n      The FreeBSD original is sane here, but even gsl is doing the same. Wonder who was first.\n \n 2nd: Masking to 48 bits not 53 makes creating uniform double values much harder.\n       Normally you would create 64-bit numbers as with every other rng. Then\n       you have proper int ranges as well as double.\n\nUse a good one instead, which works on 32bit and 64bit systems, \nproducing full range ints and doubles, and much faster. e.g wyrand. \nSee https://rurban.github.io/dieharder/QUALITY.html (the perl5 rng_drand48 test is still in work there)\n\nAnd while we are here, seperate pp_rand into int and double methods. \nIt makes not much sense to produce costly doubles, when only int values are requested.","files":null},{"type":6,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1606727230,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo0NjIwMTEyNzg="},"target":"c85086326fe326401e0c7edd4d1fd8a85b077fb283eb8d2cfb19a6023967e0b9","message":"Note that the perl5 design choices for drand48() are extremely poor. (but not entirely unexpected from p5p).\n\n1st: Taking the primitive freebsd rand48() they use ldexp(.., -48)\n       to expand the 48 bits to a double, not the much faster bitmasking.\n      ldexp uses 5 branches and 1-2 multiplications. This is ~2x slower than needed.\n      The FreeBSD original is sane here, but even gsl is doing the same. Wonder who was first.\n \n 2nd: Masking to 48 bits not 53 makes creating uniform double values much harder.\n       Normally you would create 64-bit numbers as with every other rng. Then\n       you have proper int ranges as well as double.\n\nUse a good one instead, which works on 32bit and 64bit systems, \nproducing full range ints and doubles, and much faster. e.g wyrand. \nSee https://rurban.github.io/dieharder/QUALITY.html (the perl5 rng_drand48 test is still in work there)\n\nAnd while we are here, seperate pp_rand into int and double methods. \nIt makes not much sense to produce costly doubles, when only int values are requested.","files":null},{"type":6,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1606727814,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo0NjIwMTU4MzA="},"target":"c85086326fe326401e0c7edd4d1fd8a85b077fb283eb8d2cfb19a6023967e0b9","message":"Note that the perl5 design choices for drand48() are extremely poor. (but not entirely unexpected from p5p).\n\n1st: Taking the primitive freebsd rand48() they use ldexp(.., -48)\n       to expand the 48 bits to a double, not the much faster bitmasking.\n      ldexp uses 5 branches and 1-2 multiplications. This is ~2x slower than needed.\n      The FreeBSD original is sane here, but even gsl is doing the same. Wonder who was first.\n \n 2nd: Masking to 48 bits not 53 makes creating uniform double values much harder.\n       Normally you would create 64-bit numbers as with every other rng. Then\n       you have proper int ranges as well as double.\n\nUse a good one instead, which works on 32bit and 64bit systems, \nproducing full range ints and doubles, and much faster. e.g wyrand. \nSee https://rurban.github.io/dieharder/QUALITY.html (look for drand48 at the bottom).\n\nAnd while we are here, seperate pp_rand into int and double methods. \nIt makes not much sense to produce costly doubles, when only int values are requested.","files":null},{"type":5,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1606556693,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDQwNDc4NDc5NTk="},"added":["enhancement"],"removed":[]},{"type":2,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1606558094,"metadata":{"github-id":"MDE3OlJlbmFtZWRUaXRsZUV2ZW50NDA0NzkxMjg3MQ=="},"title":"Replace the extremely poor drand48 with a proper one","was":"Replace the extremely poor drand48 with a proper one"}]}