{"version":1,"ops":[{"type":1,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1441995203,"metadata":{"github-id":"MDU6SXNzdWUxMDYwNjM3NjY=","github-url":"https://github.com/perl11/cperl/issues/7","origin":"github"},"title":"signatures","message":"TODO:\n- fix goto to hassig, treat it like a XSUB (MARK-\u003eSP): pp2sig, sig2sig, sig2pp. (_mostly done_)\n- check defgv access in the bodies, error or warn if @_ is used. This is for convenience, but needed for automatic FAKE_SIGNATURE conversion.\n- use it in most core libs (_in work, see #97_)\n\nLATER:\n- add invocant support, :self =\u003e $self as 1st argument with methods. fix the arity checker with sig-\u003eproto (multi branch)\n- convert call-by-value to ref for constants when it's made faster (inline branch)\n- multi (#16)  and method combinations (#98)\n\nSTATUS: \n- 80% faster than 5.22 sigs, 40% faster than without sigs.\n- based on PERL_FAKE_SIGNATURE by davem, can automatically convert most \n  old-style sigs to the new fast ones. this version uses the stack values directly, as with XSUBs. No @_ copying.\n- adds compile-time coretype and arity checks, references, better error messages.\n\nDONE:\n- add typechecking for cv args and return value (done with 9b77750b4b62d38dad21fbf20159b36f48c10250)\n- enable `(\\@array)` and access it as `$array-\u003e[]` arrayref, ditto for hashes. (_done_)\n- improve error reporting with sigs (name the missing arg, too many arguments: wanted 0-2, got 3, ...)\n- accept proto or sig without any feature or pragma.\n- call-by-value or ref for scalar, array and hash. i.e. copy or ref the arg.\n  bind scalarrefs transparently as in perl6 or `$_[n]` as in perl5.\n- auto-convert signature to prototype. but do not store the proto. only for compile-time arg checking.\n- accept alternative ($a?) syntax for optional arg, as in perl6\n\nSee https://github.com/perl11/cperl/commits/feature/gh7-signatures\n## Overview\n\np5p came with the worst of all signature implementions which already do exist. The slowest and with the least features, actually blocking critical progress. The newer one in a branch for 5.22 actually looks pretty good (OP_SIGNATURE),  but needs a complete rewrite so I wait on this until this lands and stabilizes.\n`smoke-me/davem/op_signature3`\n\nUpdate: It didn't land, so we use the temp. version and improve it by ourselves. See `feature/gh7-signatures` https://github.com/perl11/cperl/commits/feature/gh7-signatures\n# missing support for optional types\n\nas provided for lexical variable declarations, in leading position as\nwith `my int $a;` and as attribute, as with `($i :int :const)`\nwe need to seperate core (int, str, num) and user-defined types (class names), \nand :const. Maybe more later.\nstore the typestash similar as in pads. do it again with the new OP_SIGNATURE.\n\n```\ns = scan_word(s, PL_tokenbuf, sizeof PL_tokenbuf, TRUE, \u0026len);\ntypestash = find_in_my_stash(PL_tokenbuf, len);\nvar = parse_opt_lexvar();\nPADNAME *pn = padnamelist_fetch(PL_comppad_name, var-\u003eop_targ);\nSvPAD_TYPED_on(pn);\nPadnameTYPE_set(pn,\n  MUTABLE_HV(SvREFCNT_inc_simple_NN(MUTABLE_SV(typestash))));\n```\n# missing syntax for return types (as attr)\n\nfor easier implementation we support subattributes, :\u003ctype\u003e only. \nNote that we can add `:method` and `:const` also here.\n\n```\nsub add (int $a, int $b=1): int { $a + $b }\n```\n\n=\u003e use i_add op\n# missing syntax and support for references, call-by-ref\n\nwith perl5 all arguments are copied only, as with `my $arg1 = shift;` but \nsyntax for fast `$_[0]` access is not provided.\ncperl uses `\\$name` to denote references to scalar lvalues.\nwith constant arguments use call-by-ref also.\n\ne.g.\n\n```\nsub myfunc(int \\$i) : int { $i++ }\n```\n\nmodifies the calling argument.\n\nfor now scalar lvalue references only, `\\@a` or `\\%h` would be nice with type checks for arrayref\nor hashref.  maybe `\\[$]` also.\n# wrong overly slow treatment of @_\n\nUse the stack ABI as with OPs and XS, and do not copy the args into @_ for each call.\n@_ is empty. Use your own slurpy parameter.\nThis makes cperl signatures about 2x faster.\n\nThe following applies only to the old slow zefram purple signatures, which are not use anymore:\n\nThe elements of @_ are accessed via aelem, not aelemfast, \nthe arity check is overly big and needs two checks and big strings with fixed arity subs.\nreplace @_ with direct stackaccess ST(n) with OP_SIGNATURE.\n\n```\n./perl -Ilib -MO=Deparse -e'sub x($a){$a++}'\nsub x {\n  die sprintf(\"Too many arguments for subroutine at %s line %d.\\n\", \n    (caller)[1, 2]) unless @_ \u003c= 1;\n  die sprintf(\"Too few arguments for subroutine at %s line %d.\\n\", \n    (caller)[1, 2]) unless @_ \u003e= 1;\n  my $a = $_[0];\n  ();\n  $a++;\n}\n```\n\n=\u003e\n\n```\ndie sprintf(\"Wrong number arguments for subroutine at %s line %d.\\n\", \n  (caller)[1, 2]) if @_ != 1;\n```\n# improve error reporting\n\nIn compile-time errors do not only print the position, also the **declaration** which is violated.\ne.g.\n\n```\n@a=(); sub x(\\@b) {$b-\u003e[0]++} print x(\\$a)\n```\n\n`Type of arg 1 to main::x must be arrayref (not a scalar ref) at -e line 1, near \"\\$a)\"`\n=\u003e\n`Type of arg 1 \\@b to x must be arrayref (not a scalar ref) at -e line 1, near \"\\$a)\"`\n\n**Harmonize error message with the rest:**\n- Same compile-time and run-time error messages for the same error.\n- Skip main:: when printing the function name\n- `Not enough arguments for %s %s` as with the ops and not `Too few arguments for %s %s`\n\n**Add subroutine type and name to error message on arity errors:**\n\n```\nToo many arguments for subroutine myfunc\nToo many arguments for subroutine entry myfunc\nNot enough arguments for multi subroutine myfunc\nToo many arguments for method myfunc\n```\n\n**Disallow nameless parameters**\n\nWhen they clash with the prototype syntax.\n\n---\n\nProper signature types are not only a great help for catching errors\nearly. they are performance critical, see coffescript, dart, microsoft\ntypescript, facebook flow and hack.  the type inferencer will not be\nable to infer many types without explicit types.  but with typed\nsignatures, besides the obvious solution of private methods or closed\nclasses we can inline most small methods, and improve most loops and\narray accesses. it is also critical to implement multi methods, i.e. proper multi-dispatch, \nwhich would enable a proper oo system within perl5. \nDios is close but a hack (PPI macros!), and only with Inside-Out objects.","files":null}]}