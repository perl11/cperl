{"version":1,"ops":[{"type":1,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1441996670,"metadata":{"github-id":"MDU6SXNzdWUxMDYwNjc4MTE=","github-url":"https://github.com/perl11/cperl/issues/14","origin":"github"},"title":"native unboxed types","message":"a major memory and performance win.\n\nas native types in Perl6\nnew `box_{int,num,str}` and `unbox_{int,num,str}` ops, and all the arithmetic ops for int and num, and for const and padsv (padav for native arrays later).\n\nAllow native int, double and ASCIIZ pointers on the stack, and provide optimized ops for those.\nMaybe uni strings later.\n\nCheck in the compiler (op.c) for safe ranges to use unboxed sequences of ops, and box the stack values when escaping: sub calls, exceptions, jumps outside.\n\nI needed to extend opcodes and opcode.pl to mark the ops with new arg types, change msgrcv and sockpair, because there's no room for 5 op args anymore (no, undone.)\n\ntype num (double) can only be used when IVSIZE==NVSIZE, i.e. 32bit with NV=float and 64bit with double. The compiler needs to emits different code when unboxed num is avail. or not.\n\nOptimizer:\nnative types strength reduction:\nChange ops with typed or const args into typed.\ne.g. padsv[$a:int] const(iv) add =\u003e i_add\n\nWith more than 2 ops with unboxable args, maybe unbox it.\ne.g. `padsv[$a:int] const(iv) add padsv[$b:int] multiply`\n=\u003e \n\n```\n padsv[$a:int] const(iv) unbox[2] int_add\n padsv[$b:int] unbox int_multiply[b]\n```\n\n[b] meaning box result as in box_int\n\nnative ops can have OPpBOXRET and UNBOX_\\* can have the number of stack elements in op_private. Extend B::Concise to display those, and also display the types of pads, like\n`padsv[$a:int 63,64]`\n\nI had a major thinko btw. Those ops can only refer to other ops, never to data directly. The data ops are const and padsv. Either the native arith ops replace in the optimizer the padsv/const ops by the unboxed variants, where op_first/op_last points to an unboxed data (ptr or literal const?, ptr tagging cannot be used as we need all bits for the literal, which might end with 0b00)\nso we need new types const_int, pad_int, ... which hold the unboxed data.\n\nint_padsv holds the data in special curpad[] SVs with SVf_NATIVE. Or keep it there unboxed, but then we need to assure that all the padops referring to this targ are changed to be properly typed.\n\nSee `feature/CM-713-cperl-native-types`","files":null}]}