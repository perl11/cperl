{"version":1,"ops":[{"type":1,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1451517023,"metadata":{"github-id":"MDU6SXNzdWUxMjQ0MTIwODc=","github-url":"https://github.com/perl11/cperl/issues/102","origin":"github"},"title":"small hash","message":"optimize hashes with \u003c= 3-5 keys to a simple array of keys and values with linear lookup.\n\n`HvSMALL(hv) / XHvSMALL(xhv)` is either checking HvMAX \u003c 7, or a flag. If a flag the very first HE\\* entry needs to be a non-ptr tag (\u0026 0x1).\nWe'd need a flag with inlined HEs and overlong keys, to omit HvSMALL optims with such long keys.\nWe cannot the hv_aux based HvFLAGS with normal HvSMALL hashes, esp. when inlined.\n\nThe best would be a he-array alike inlined len/char*/flags/val array to be cache concious. (as in #24 `feature/gh24-he-array`). The len really should be run-length encoded, then the flags needed for hash cmp need to come first.\nHowever at first we start with simple HE\\* arrays. (array of ptrs, not values)\nThe last array element needs to have an NULL sentinel, so we cannot use all 7 HE*, only 6.\n\nBut there are many more simple hash optims, which we do first.\n- extract uncommon magical code from hv_common\n- add __builtin_ctz support (count trailing zeros) and use it instead of division on DO_HSPLIT (done with the builtin-ctz branch)\n- pre-extend hashes as in aassign with av_extend, when the number of keys is on the stack. This speeds up all the big hash inits (e.g. warnings.pm), needing no costly series of splits during initialization.","files":null}]}