{"version":1,"ops":[{"type":1,"author":{"id":"04135dc995e2fdcd322aaf4268dbf04630a3cc7c"},"timestamp":1497297107,"metadata":{"github-id":"MDU6SXNzdWUyMzUzNDYyOTE=","github-url":"https://github.com/perl11/cperl/issues/294","origin":"github"},"title":":const sv init","message":"With #291 I fixed :const sv handling. Previously only const subs were made const. \nNow \n```\nour %bug_tracker :const = (\n    'App::Cpan'             =\u003e undef,\n...\n);\n``` \nwill fail adding to the hash at runtime. Defer the attributes-\u003eimport call after the statement.\nThis is easier than my old approach a few years ago with private assign bits in the `typed/const` branch.\n\nWithout a fix `my $var :const` is useless, as you cannot assign any values to it.\n\n1.  This must be done either via massive OP flags trickery (CONST_INIT -\u003e\n    {a,s}assign). See my 5 year old [typed/const branch](https://github.com/perl11/cperl/commits/typed/const) with\n    STATE,CONSTINIT,CONST bits for all pad ops, PAD bit for const,\n    plus OPf_SPECIAL for {a,s}assign, plus run-time checks. But it catches\n    writing to such const vars at compile-time.\n    commit 1fc087d778923690ff6579cbface1c2b433c6d8b \n\n2. Or simply just in the parser, moving the attribute-\u003eimport call after\n    the assignment.\n    No run-time READONLY unset/set, no compile-time catches of writing to\n    such a const var.\n\n3. Both. Use the deferred attribute-\u003eimport call simply in the parser to avoid checking both assign ops for the :const case at run-time. Set the var READONLY already plus a special CONST bit/change from OP_PADxV to OP_CONST to catch wrong compile-time writes, and enable constant folding and more compile-time checks and optims, like shaped arrays and types.\n\nDone with 1e6d6978be875f65a0eeb504e2cc33c970839377 in master.","files":null}]}