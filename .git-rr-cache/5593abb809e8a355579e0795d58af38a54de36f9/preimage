/* ex: set ro ft=c: -*- buffer-read-only: t; mode: c; c-basic-offset: 4; -*-
  !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
  This file is built by ext/warnings/warnings_xs.PL and ext/warnings/warnings_xs.in. */
/* ANSI-C code produced by gperf version 3.0.4 */
/* Command-line: gperf --output-file=ext/warnings/warnings.xs ext/warnings/warnings_xs.in  */
/* Computed positions: -k'3,15,$' */

#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
/* The character set is not based on ISO-646.  */
#  error "gperf generated tables don't work with this non ISO-646 based character set."
#endif

#line 1 "ext/warnings/warnings_xs.in"
/* -*- mode: c; c-basic-offset: 4; -*-

Copyright (C) 2015, cPanel Inc

=head1 NAME

ext/warnings/warnings.xs - gperf generated read-only warnings hash as shared library

=head1 DESCRIPTION

Generated warnings hash from F<ext/warnings/warnings_xs.in> via F<ext/warnings/warnings_xs.PL>

C<gperf --output-file=ext/warnings/warnings.xs ext/warnings/warnings_xs.in>
with cleanups for header, inline, C++ and c89.

The hashes C<%Bits>, C<%DeadBits> are tied to the the values in the
const wordlist perfect hash.  Only the C<all> key is writable, but the
hash is extendable.  Every read-access goes first through the perfect
hash, and then into a normal perl hash, to be able to register custom
user-categories. We assume almost nobody needs to create his own user
category, so penalize this.

=over 4

=item C<struct Perl_warnings>

Structure of generated read-only hash table with name, offsets, bits and deadbits.

=back

=head2 Functions

=over 4

=item C<struct Perl_warnings * Perl_warnings_lookup(register const
char *str, register unsigned int len)>

API function to access the generated hash.

=item C<struct Perl_warnings * warnings_const_lookup(register const
char *str, register unsigned int len)>

Generated lookup function to access to read-only compile-time part of the hash.

=back

=cut

*/

#define PERL_NO_GET_CONTEXT
#define PERL_EXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "warnings.h"

#undef USE_PP_CARP
#define WNORMAL  1
#define WFATAL   2
#define WMESSAGE 4

#define AV_PUSH(av, val) av_store(av, AvFILLp(av)+1, val)

struct Perl_warnings { int name; const U8 offset; const char *bits; const char *deadbits; };
struct Perl_warnings_dyn { int name; U8 offset; char *bits; char *deadbits; SV *base; };
struct Perl_warnings_dyn ws;
struct Perl_warnings *
Perl_warnings_lookup (register const char *str, register unsigned int len);

#line 80 "ext/warnings/warnings_xs.in"
struct Perl_warnings;

#define TOTAL_KEYWORDS 68
#define MIN_WORD_LENGTH 2
#define MAX_WORD_LENGTH 27
#define MIN_HASH_VALUE 4
#define MAX_HASH_VALUE 114
/* maximum key range = 111, duplicates = 0 */

static unsigned int
warnings_hash (register const char *str, register unsigned int len)
{
  static unsigned char asso_values[] =
    {
      115, 115, 115, 115, 115, 115, 115, 115, 115, 115,
      115, 115, 115, 115, 115, 115, 115, 115, 115, 115,
      115, 115, 115, 115, 115, 115, 115, 115, 115, 115,
      115, 115, 115, 115, 115, 115, 115, 115, 115, 115,
      115, 115, 115, 115, 115, 115, 115, 115, 115, 115,
      115, 115, 115, 115, 115, 115,  40, 115, 115, 115,
      115, 115, 115, 115, 115, 115, 115, 115, 115, 115,
      115, 115, 115, 115, 115, 115, 115, 115, 115, 115,
      115, 115, 115, 115, 115, 115, 115, 115, 115, 115,
      115, 115, 115, 115, 115, 115, 115,   0,  90,  30,
       20,   0,  45,  55,  60, 115,  45,  60,  40,  40,
       25,  20,  20,   0,  20,   5,  30,   5, 115,  55,
       25, 115,   0, 115, 115, 115, 115, 115, 115, 115,
      115, 115, 115, 115, 115, 115, 115, 115, 115, 115,
      115, 115, 115, 115, 115, 115, 115, 115, 115, 115,
      115, 115, 115, 115, 115, 115, 115, 115, 115, 115,
      115, 115, 115, 115, 115, 115, 115, 115, 115, 115,
      115, 115, 115, 115, 115, 115, 115, 115, 115, 115,
      115, 115, 115, 115, 115, 115, 115, 115, 115, 115,
      115, 115, 115, 115, 115, 115, 115, 115, 115, 115,
      115, 115, 115, 115, 115, 115, 115, 115, 115, 115,
      115, 115, 115, 115, 115, 115, 115, 115, 115, 115,
      115, 115, 115, 115, 115, 115, 115, 115, 115, 115,
      115, 115, 115, 115, 115, 115, 115, 115, 115, 115,
      115, 115, 115, 115, 115, 115, 115, 115, 115, 115,
      115, 115, 115, 115, 115, 115, 115
    };
  register int hval = len;

  switch (hval)
    {
      default:
        hval += asso_values[(unsigned char)str[14]];
      /*FALLTHROUGH*/
      case 14:
      case 13:
      case 12:
      case 11:
      case 10:
      case 9:
      case 8:
      case 7:
      case 6:
      case 5:
      case 4:
      case 3:
        hval += asso_values[(unsigned char)str[2]+1];
      /*FALLTHROUGH*/
      case 2:
        break;
    }
  return hval + asso_values[(unsigned char)str[len - 1]];
}

struct stringpool_t
  {
    char stringpool_str4[sizeof ("pipe")];
    char stringpool_str7[sizeof ("inplace")];
    char stringpool_str8[sizeof ("redefine")];
    char stringpool_str10[sizeof ("untie")];
    char stringpool_str13[sizeof ("portable")];
    char stringpool_str14[sizeof ("surrogate")];
    char stringpool_str17[sizeof ("threads")];
    char stringpool_str21[sizeof ("parenthesis")];
    char stringpool_str22[sizeof ("io")];
    char stringpool_str24[sizeof ("once")];
    char stringpool_str25[sizeof ("layer")];
    char stringpool_str26[sizeof ("locale")];
    char stringpool_str27[sizeof ("closure")];
    char stringpool_str29[sizeof ("prototype")];
    char stringpool_str30[sizeof ("deprecated")];
    char stringpool_str31[sizeof ("non_unicode")];
    char stringpool_str32[sizeof ("newline")];
    char stringpool_str33[sizeof ("bareword")];
    char stringpool_str34[sizeof ("experimental::signatures")];
    char stringpool_str36[sizeof ("imprecision")];
    char stringpool_str39[sizeof ("redundant")];
    char stringpool_str43[sizeof ("syscalls")];
    char stringpool_str44[sizeof ("ambiguous")];
    char stringpool_str46[sizeof ("closed")];
    char stringpool_str47[sizeof ("nonchar")];
    char stringpool_str48[sizeof ("unopened")];
    char stringpool_str49[sizeof ("experimental::regex_sets")];
    char stringpool_str51[sizeof ("syntax")];
    char stringpool_str52[sizeof ("experimental")];
    char stringpool_str53[sizeof ("internal")];
    char stringpool_str54[sizeof ("recursion")];
    char stringpool_str55[sizeof ("precedence")];
    char stringpool_str56[sizeof ("substr")];
    char stringpool_str57[sizeof ("qw")];
    char stringpool_str58[sizeof ("reserved")];
    char stringpool_str59[sizeof ("semicolon")];
    char stringpool_str61[sizeof ("severe")];
    char stringpool_str62[sizeof ("numeric")];
    char stringpool_str64[sizeof ("misc")];
    char stringpool_str66[sizeof ("unpack")];
    char stringpool_str68[sizeof ("experimental::autoderef")];
    char stringpool_str69[sizeof ("void")];
    char stringpool_str71[sizeof ("experimental::lexical_subs")];
    char stringpool_str72[sizeof ("illegalproto")];
    char stringpool_str73[sizeof ("experimental::re_strict")];
    char stringpool_str74[sizeof ("experimental::const_attr")];
    char stringpool_str76[sizeof ("malloc")];
    char stringpool_str78[sizeof ("uninitialized")];
    char stringpool_str79[sizeof ("exec")];
    char stringpool_str80[sizeof ("taint")];
    char stringpool_str83[sizeof ("all")];
    char stringpool_str84[sizeof ("pack")];
    char stringpool_str86[sizeof ("regexp")];
    char stringpool_str88[sizeof ("experimental::postderef")];
    char stringpool_str89[sizeof ("experimental::smartmatch")];
    char stringpool_str92[sizeof ("missing")];
    char stringpool_str94[sizeof ("debugging")];
    char stringpool_str95[sizeof ("digit")];
    char stringpool_str96[sizeof ("printf")];
    char stringpool_str97[sizeof ("experimental::lexical_topic")];
    char stringpool_str99[sizeof ("utf8")];
    char stringpool_str100[sizeof ("experimental::refaliasing")];
    char stringpool_str101[sizeof ("experimental::win32_perlio")];
    char stringpool_str106[sizeof ("signal")];
    char stringpool_str107[sizeof ("exiting")];
    char stringpool_str108[sizeof ("overflow")];
    char stringpool_str111[sizeof ("experimental::bitwise")];
    char stringpool_str114[sizeof ("glob")];
  };
static struct stringpool_t stringpool_contents =
  {
    "pipe",
    "inplace",
    "redefine",
    "untie",
    "portable",
    "surrogate",
    "threads",
    "parenthesis",
    "io",
    "once",
    "layer",
    "locale",
    "closure",
    "prototype",
    "deprecated",
    "non_unicode",
    "newline",
    "bareword",
    "experimental::signatures",
    "imprecision",
    "redundant",
    "syscalls",
    "ambiguous",
    "closed",
    "nonchar",
    "unopened",
    "experimental::regex_sets",
    "syntax",
    "experimental",
    "internal",
    "recursion",
    "precedence",
    "substr",
    "qw",
    "reserved",
    "semicolon",
    "severe",
    "numeric",
    "misc",
    "unpack",
    "experimental::autoderef",
    "void",
    "experimental::lexical_subs",
    "illegalproto",
    "experimental::re_strict",
    "experimental::const_attr",
    "malloc",
    "uninitialized",
    "exec",
    "taint",
    "all",
    "pack",
    "regexp",
    "experimental::postderef",
    "experimental::smartmatch",
    "missing",
    "debugging",
    "digit",
    "printf",
    "experimental::lexical_topic",
    "utf8",
    "experimental::refaliasing",
    "experimental::win32_perlio",
    "signal",
    "exiting",
    "overflow",
    "experimental::bitwise",
    "glob"
  };
#define stringpool ((const char *) &stringpool_contents)

struct Perl_warnings *
warnings_const_lookup (register const char *str, register unsigned int len)
{
  static struct Perl_warnings wordlist[] =
    {
      {-1, 0, NULL, NULL}, {-1, 0, NULL, NULL}, {-1, 0, NULL, NULL}, {-1, 0, NULL, NULL},
#line 92 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str4, 20, "\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL}, {-1, 0, NULL, NULL},
#line 105 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str7, 46, "\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 101 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str8, 38, "\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL},
#line 125 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str10, 86, "\0\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL}, {-1, 0, NULL, NULL},
#line 99 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str13, 34, "\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 132 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str14, 100, "\0\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL}, {-1, 0, NULL, NULL},
#line 122 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str17, 80, "\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL}, {-1, 0, NULL, NULL}, {-1, 0, NULL, NULL},
#line 114 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str21, 64, "\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 87 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str22, 10, "\0\124\125\0\0\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\250\252\0\0\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL},
#line 96 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str24, 28, "\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 90 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str25, 16, "\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 147 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str26, 130, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 83 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str27, 2, "\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL},
#line 117 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str29, 70, "\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 84 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str30, 4, "\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 130 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str31, 96, "\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 91 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str32, 18, "\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 112 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str33, 60, "\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 140 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str34, 116, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL},
#line 128 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str36, 92, "\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL}, {-1, 0, NULL, NULL},
#line 149 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str39, 134, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL}, {-1, 0, NULL, NULL}, {-1, 0, NULL, NULL},
#line 141 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str43, 118, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 111 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str44, 58, "\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL},
#line 88 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str46, 12, "\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 131 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str47, 98, "\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 93 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str48, 22, "\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 136 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str49, 108, "\0\0\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL},
#line 110 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str51, 56, "\0\0\0\0\0\0\0\125\125\25\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\252\252\52\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 133 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str52, 102, "\0\0\0\0\0\0\0\0\0\0\0\0\100\125\25\125\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\200\252\52\252\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 106 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str53, 48, "\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 100 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str54, 36, "\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 115 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str55, 66, "\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 109 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str56, 54, "\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 118 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str57, 72, "\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 119 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str58, 74, "\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 120 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str59, 76, "\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL},
#line 103 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str61, 42, "\0\0\0\0\0\124\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\250\12\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 95 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str62, 26, "\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL},
#line 94 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str64, 24, "\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL},
#line 124 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str66, 84, "\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL},
#line 138 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str68, 112, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 127 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str69, 90, "\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL},
#line 134 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str71, 104, "\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 129 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str72, 94, "\0\0\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 144 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str73, 124, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 143 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str74, 122, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL},
#line 107 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str76, 50, "\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL},
#line 123 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str78, 82, "\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 89 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str79, 14, "\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 121 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str80, 78, "\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL}, {-1, 0, NULL, NULL},
#line 82 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str83, 0, "\125\125\125\125\125\125\125\125\125\125\125\125\125\125\125\125\125\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\252\252\252\252\252\252\252\252\252\252\252\252\252\252\252\252\252\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 98 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str84, 32, "\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL},
#line 102 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str86, 40, "\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL},
#line 139 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str88, 114, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 137 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str89, 110, "\0\0\0\0\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL}, {-1, 0, NULL, NULL},
#line 148 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str92, 132, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL},
#line 104 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str94, 44, "\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 113 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str95, 62, "\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 116 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str96, 68, "\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 135 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str97, 106, "\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL},
#line 126 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str99, 88, "\0\0\0\0\0\0\0\0\0\0\0\1\25\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\2\52\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 145 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str100, 126, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 146 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str101, 128, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL}, {-1, 0, NULL, NULL}, {-1, 0, NULL, NULL}, {-1, 0, NULL, NULL},
#line 108 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str106, 52, "\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 85 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str107, 6, "\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
#line 97 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str108, 30, "\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL}, {-1, 0, NULL, NULL},
#line 142 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str111, 120, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},
      {-1, 0, NULL, NULL}, {-1, 0, NULL, NULL},
#line 86 "ext/warnings/warnings_xs.in"
      {(int)(long)&((struct stringpool_t *)0)->stringpool_str114, 8, "\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"}
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      register int key = warnings_hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= 0)
        {
          register int o = wordlist[key].name;
          if (o >= 0)
            {
              register const char *s = o + stringpool;

              if (*str == *s && !strcmp (str + 1, s + 1))
                return &wordlist[key];
            }
        }
    }
  return 0;
}
#line 150 "ext/warnings/warnings_xs.in"


/* We really need to zero the bits */
static SV *
newWSV(const char *str, const int len) {
    SV *sv = newSV(WARN_MAX_BYTES);
    /*SvUPGRADE(sv, SVt_PV); --unneeded*/
    SvCUR_set(sv, WARN_MAX_BYTES);
    SvPOK_on(sv);
    Zero(SvPVX(sv), WARN_MAX_BYTES, char);
    if (len)
        Move(str, SvPVX(sv), len, char);
    return sv;
}

/* static compile-time length */
#define newWSVpvs(str) newWSV(STR_WITH_LEN(str))
/* dynamic max length */
#define newWSVpv(str) newWSV(str, WARN_MAX_BYTES)
/* static length from header */
#define newWSVpvh(str) newWSV(str, WARNsize)

struct Perl_warnings *
Perl_warnings_lookup (register const char *str, register unsigned int len) {
    const struct Perl_warnings *w = warnings_const_lookup(str, len);
    if (memEQs(str, len, "all") || !w) {
        SV **bit;
        HV * const bits = get_hv("warnings::_Bits", 0);
        if (bits && ((bit = hv_fetch(bits, str, len, FALSE)))) {
            char *p = SvPVX(*bit);
            struct Perl_warnings_dyn *w1 = &ws;
            STRLEN l = SvCUR(*bit) / 2;
            w1->offset   = SvIVX(*bit);
            w1->bits     = p;
            w1->deadbits = p + l;
            w1->base = *bit;
            return (struct Perl_warnings *)w1;
        } else {
            return NULL;
        }
    }
    return (struct Perl_warnings *)w;
}

static int _chk(const char *sub, U32 flags, I32 ax) {
    dSP;
    SV **mark = PL_stack_base + ax - 1;
    dITEMS;
    SV *message, *mask;
    char *category;
    const struct Perl_warnings *w;
    const PERL_CONTEXT *cx;
    int i, is_obj = 0;
    int has_message = flags & WMESSAGE;
    int results_0 = 0, results_1 = 0;
    STRLEN * old_warnings;

    if (!(items == 1 || items == (has_message ? 2 : 0))) {
#ifdef USE_PP_CARP
        SV *msg = newSVpvs("");
        sv_catpvf(msg, "Usage: warnings::%s(%s)", sub, has_message ? "[category,] 'message'" : "[category]");
        PUSHMARK(SP);
        mXPUSHs(msg);
        PUTBACK;
        call_pv("warnings::Croaker", G_DISCARD);
        SPAGAIN;
#else
        /*croak_sv(carp_shortmess(ax, msg));*/
        croak("Usage: warnings::%s(%s)", sub, has_message ? "[category,] 'message'" : "[category]");
#endif
    }
    if (has_message) {
        message = items == 1 ? ST(0) : ST(1);
        if (SvREADONLY(message))
            message = newSVpvn(SvPVX(message), SvCUR(message));
        items--;
    } else {
        message = newSVpvs("");
    }
    if (items > 0) {
        if (SvOBJECT(ST(0))) {
            category = HvNAME(SvSTASH(ST(0)));
            is_obj = 1;
        } else if (SvPOK(ST(0))) {
            category = SvPVX(ST(0));
        } else {
            category = NULL;
#ifdef USE_PP_CARP
            PUSHMARK(SP);
            mXPUSHs(newSVpvs("not an object"));
            PUTBACK;
            call_pv("warnings::Croaker", G_DISCARD);
            SPAGAIN;
#else
            croak_sv(carp_shortmess(ax, newSVpvs("not an object")));
#endif
        }
    } else {
        /* when called from pp warnings::* then caller 0, else just curcop */
        const PERL_CONTEXT *cx = caller_cx(0, NULL);
        category = HvNAME(CopSTASH(cx ? cx->blk_oldcop : PL_curcop));
    }

    w = Perl_warnings_lookup(category, strlen(category));
    if (!w) {
        SV *msg = newSVpvs("");
        if (items > 0)
            sv_catpvf(msg, "Unknown warnings category '%s'", category);
        else
            sv_catpvf(msg, "package '%s' not registered for warnings", category);
#ifdef USE_PP_CARP
        PUSHMARK(SP);
        mXPUSHs(msg);
        PUTBACK;
        call_pv("warnings::Croaker", G_DISCARD);
        SPAGAIN;
#else
        croak_sv(carp_shortmess(ax, msg));
#endif
    }

    if (is_obj) {
        /* walk the callstack and find category */
	SV *eval = newSVpvs("my ($i, $pkg) = (2);\n"
"  while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n"
"    last unless @DB::args && $DB::args[0] =~ /^");
        sv_catpv(eval, category);
        sv_catpvs(eval, "=/;} $i");
        if (eval_sv(eval, G_SCALAR)) { SPAGAIN; i = TOPi - 2; }
        else i = 0;
#ifdef DEBUGGING
        if (DEBUG_v_TEST_)
            Perl_deb("warnings::%s is_obj => cx_depth=%d\n", sub, i);
#endif
        SvREFCNT_dec(eval);
    } else {
#ifdef USE_PP_CARP
        eval_sv(newSVpvs("require Carp;"), G_DISCARD);
        PUSHMARK(SP);
        PUTBACK;
        i = call_pv("Carp::short_error_loc", G_SCALAR);
        SPAGAIN;
        if (i)
            i = (int)TOPi;
        DEBUG_v(deb("Carp::short_error_loc: %d\n", i));
#else
        /* TODO Still buggy, off-by-one
           i = short_error_loc(); */
        i = long_error_loc();
        DEBUG_v(deb("long_error_loc: %d\n", i));
#endif
    }

    if (i == 0) /* A XS speciality */
        old_warnings = PL_curcop->cop_warnings;
    else if ((cx = caller_cx(i, NULL)))
        old_warnings = cx->blk_oldcop->cop_warnings;
    else
        old_warnings = pWARN_NONE;

    if  (old_warnings == pWARN_NONE)
        mask = newWSVpvh(WARN_NONEstring);
    else if (old_warnings == pWARN_STD && !(PL_dowarn & G_WARN_ON))
        mask = newWSVpvh(WARN_DEFAULTstring);
    else if (old_warnings == pWARN_ALL ||
             (old_warnings == pWARN_STD && (PL_dowarn & G_WARN_ON))) {
        const struct Perl_warnings *w_all = Perl_warnings_lookup("all", 3);
        mask = newWSVpv(w_all->bits);
    }
    else {
        assert(!specialWARN(old_warnings));
        mask = newSVpvn((char *) (old_warnings + 1), old_warnings[0]);
    }
#ifdef DEBUGGING
    if (DEBUG_v_TEST_) {
        SV *dsv = newSVpvn("", 80);
        Perl_deb("warnings::%s %s %d %s\n", sub, category, i,
                 pv_display( dsv, SvPVX(mask), SvCUR(mask), SvCUR(mask), 80));
        SvREFCNT_dec(dsv);
    }
#endif
    if (flags & WFATAL) {
        const char* m = SvPVX(mask);
        results_0 = IsSet(m, w->offset + WFATAL - 1);
        if (w->offset && !results_0) results_0 = IsSet(m, WFATAL - 1);
    }
    if (flags & WNORMAL) {
        const char* m = SvPVX(mask);
        results_1 = IsSet(m, w->offset + WNORMAL - 1);
        if (w->offset && !results_1) results_1 = IsSet(m, WNORMAL - 1);
    }
    SvREFCNT_dec(mask);
    /* &enabled and &fatal_enabled */
    if (!has_message)
        return results_0 ? results_0 : results_1;
    /* &warnif, and the category is neither enabled as warning nor as fatal */
    if (flags == (WNORMAL | WFATAL | WMESSAGE) && !(results_0 | results_1))
        return 0;
    if (results_0) {
#ifdef USE_PP_CARP
        PUSHMARK(SP);
        XPUSHs(message);
        PUTBACK;
        call_pv("warnings::Croaker", G_DISCARD);
        SPAGAIN;
#else
        croak_sv(carp_longmess(ax, message));
#endif
    }
    /* will always get here for &warn. will only get here for &warnif if the
       category is enabled */
#ifdef USE_PP_CARP
    if (is_obj)
        eval_sv(newSVpvs("require Carp;"), G_DISCARD);
    PUSHMARK(SP);
    XPUSHs(message);
    PUTBACK;
    call_pv("Carp::carp", G_DISCARD);
    SPAGAIN;
#else
    warn_sv(carp_shortmess(ax, message));
#endif
    return 1;
}

/* sv_magic_set ${^WARNINGS_BITS} = mask */
static void
_set_warn_bits(const char *func, const char* arg, SV *mask) {
#ifdef DEBUGGING
    if (DEBUG_v_TEST_) {
        SV *dsv = newSVpvn("", 80);
        Perl_deb("warnings::%s %s %s\n", func, arg,
                 pv_display( dsv, SvPVX(mask), SvCUR(mask), SvCUR(mask), 80));
        SvREFCNT_dec(dsv);
    }
#endif
    if (PL_dowarn & G_WARN_ALL_MASK) return;
#if 1
    /* we always call it with a string */
    if (!SvPOK(mask)) {
        PL_compiling.cop_warnings = pWARN_STD;
        return;
    }
#endif
    if (memEQs(SvPVX(mask), WARN_MAX_BYTES, WARN_ALLstring)) {
        if (!specialWARN(PL_compiling.cop_warnings))
            PerlMemShared_free(PL_compiling.cop_warnings);
        PL_compiling.cop_warnings = pWARN_ALL;
        PL_dowarn |= G_WARN_ONCE;
    } else if (memEQs(SvPVX(mask), WARN_MAX_BYTES, WARN_NONEstring)) {
        if (!specialWARN(PL_compiling.cop_warnings))
            PerlMemShared_free(PL_compiling.cop_warnings);
        PL_compiling.cop_warnings = pWARN_NONE;
    } else {
        PL_compiling.cop_warnings
            = Perl_new_warnings_bitfield(aTHX_ PL_compiling.cop_warnings,
                                         SvPVX(mask), SvCUR(mask));
        if (isWARN_on(PL_compiling.cop_warnings, WARN_ONCE))
            PL_dowarn |= G_WARN_ONCE;
    }
}

<<<<<<<
static SV*
_do_bits(SV *mask, const SV * const word, int fatal, int nonfatal) {
    if (SvPOK(word)) {
        const struct Perl_warnings *w = Perl_warnings_lookup(SvPVX_const(word), SvCUR(word));
        if (w) {
            do_vop(OP_BIT_OR, mask, mask, newWSVpv(w->bits));
            if (fatal)
                do_vop(OP_BIT_OR, mask, mask, newWSVpv(w->deadbits));
            if (nonfatal) {
                U8 *p;
                STRLEN j;
                SV *tmp = newWSVpvs("");
                do_vop(OP_BIT_OR, tmp, newWSVpv(w->deadbits), newWSVpvs("\3"));
                /* scomplement is static */
                for (p=(U8*)SvPVX(tmp), j=0; j<SvCUR(tmp); j++) {
                    const U8 c = *p;
                    *p++ = ~c;
                }
                do_vop(OP_BIT_AND, mask, mask, tmp);
                SvREFCNT_dec(tmp);
            }
            return mask;
        } else {
#ifdef USE_PP_CARP
            dSP;
#else
            I32 ax = TOPMARK - 1; /* ??? Test with Carp XS */
#endif
            SV *msg = newSVpvs("Unknown warnings category '");
            sv_catsv(msg, (SV *const)word);
            sv_catpvs(msg, "'");
            /* But here the fallback to pp warnings::Croaker does not work */
#ifdef USE_PP_CARP
            PUSHMARK(SP);
            mXPUSHs(msg);
            PUTBACK;
            call_pv("warnings::Croaker", G_DISCARD);
            SPAGAIN;
#else
            croak_sv(carp_shortmess(ax, msg));
#endif
            return NULL;
        }
    }
    return NULL;
}


=======
static SV*
_do_bits(SV *mask, const SV * const word, int fatal, int nonfatal) {
    if (SvPOK(word)) {
        const struct Perl_warnings *w = Perl_warnings_lookup(SvPVX_const(word), SvCUR(word));
        if (w) {
            do_vop(OP_BIT_OR, mask, mask, newWSVpv(w->bits));
            if (fatal)
                do_vop(OP_BIT_OR, mask, mask, newWSVpv(w->deadbits));
            if (nonfatal) {
                U8 *p;
                STRLEN j;
                SV *tmp = newWSVpvs("");
                do_vop(OP_BIT_OR, tmp, newWSVpv(w->deadbits), newWSVpvs("\3"));
                /* scomplement is static */
                for (p=(U8*)SvPVX(tmp), j=0; j<SvCUR(tmp); j++) {
                    const U8 c = *p;
                    *p++ = ~c;
                }
                do_vop(OP_BIT_AND, mask, mask, tmp);
                SvREFCNT_dec(tmp);
            }
            return mask;
        } else {
#ifdef USE_PP_CARP
            dSP;
#else
            dORIGMARK;
            I32 ax = TOPMARK - 1; /* ??? Test with Carp XS */
#endif
            SV *msg = newSVpvs("Unknown warnings category '");
            sv_catsv(msg, word);
            sv_catpvs(msg, "'");
            /* But here the fallback to pp warnings::Croaker does not work */
#ifdef USE_PP_CARP
            PUSHMARK(SP);
            mXPUSHs(msg);
            PUTBACK;
            call_pv("warnings::Croaker", G_DISCARD);
            SPAGAIN;
#else
            croak_sv(carp_shortmess(ax, msg));
#endif
            return NULL;
        }
    }
    return NULL;
}


>>>>>>>
MODULE = warnings		PACKAGE = warnings

void
_bits (mask, ...)
     SV *mask
PREINIT:
    int i;
    int fatal = 0, no_fatal = 0;
PPCODE:
    if (!SvPOK(mask))
        mask = newWSVpvh(WARN_NONEstring);
    for (i=1; i<items; i++) {
        SV *word = ST(i);
        if (SvPOK(word)) {
            if (memEQs(SvPVX(word), SvCUR(word), "FATAL")) {
                fatal = 1;
                no_fatal = 0;
            } else
            if (memEQs(SvPVX(word), SvCUR(word), "NONFATAL")) {
                fatal = 0;
                no_fatal = 1;
            } else {
                mask = _do_bits(mask, word, fatal, no_fatal);
            }
        }
    }
    TOPs = mask;
    XSRETURN(1);

void
bits (...)
PPCODE:
    PUSHMARK(SP);
    mXPUSHs(&PL_sv_undef);
    if (!items)
        mXPUSHs(newSVpvs("all"));
    PUTBACK;
    if (call_pv("warnings::_bits", G_SCALAR)) {
        SPAGAIN;
        XSRETURN(1);
    } else
        XSRETURN_UNDEF;

void
import (klass, ...)
    SV* klass
PREINIT:
    SV *mask;
    struct Perl_warnings *w_all = NULL;
PPCODE:
    if (!SvPOK(klass))
        croak_xs_usage(cv,  "class, ...");
    /* mask = ${^WARNING_BITS} // ($^W ? $Bits{all} : $DEFAULT); */
    if (specialWARN(PL_compiling.cop_warnings)) {
        if (PL_dowarn & G_WARN_ON || PL_compiling.cop_warnings == pWARN_ALL) {
            w_all = Perl_warnings_lookup("all", 3);
            mask = newWSVpv(w_all->bits);
        } else if (PL_compiling.cop_warnings == pWARN_NONE) {
            mask = newWSVpvh(WARN_NONEstring);
        } else {
            mask = newWSVpvh(WARN_DEFAULTstring);
        }
    } else
        mask = newSVpvn((char*)((STRLEN*)PL_compiling.cop_warnings+1), *PL_compiling.cop_warnings);

    if (IsSet(SvPVX(mask), 0)) {
        if (!w_all) w_all = Perl_warnings_lookup("all", 3);
        do_vop(OP_BIT_OR, mask, mask, newWSVpv(w_all->bits));
        if (IsSet(SvPVX(mask), 1))
            do_vop(OP_BIT_OR, mask, mask, newWSVpv(w_all->deadbits));
    }
    if (items > 1) {
        int i;
        SV *word;
        int fatal = 0, no_fatal = 0;
        for (i=1; i<items; i++) {
            word = ST(i);
            if (SvPOK(word)) {
                if (memEQs(SvPVX(word), SvCUR(word), "FATAL")) {
                    fatal = 1;
                    no_fatal = 0;
                } else
                    if (memEQs(SvPVX(word), SvCUR(word), "NONFATAL")) {
                        fatal = 0;
                        no_fatal = 1;
                    } else {
                        mask = _do_bits(mask, word, fatal, no_fatal);
                    }
            }
        }
        word = ST(1);
        /* push @_, 'all' if @_==1 && ( $_[0] eq 'FATAL' || $_[0] eq 'NONFATAL' ); */
        if (items == 2 && SvPOK(word)) {
            if (memEQs(SvPVX(word), SvCUR(word), "FATAL"))
                mask = _do_bits(mask, newSVpvs("all"), 1, 0);
            else if (memEQs(SvPVX(word), SvCUR(word), "NONFATAL"))
                mask = _do_bits(mask, newSVpvs("all"), 0, 1);
        }
        _set_warn_bits("import", SvPVX(word), mask);
    } else {
        if (!w_all) w_all = Perl_warnings_lookup("all", 3);
        do_vop(OP_BIT_OR, mask, mask, newWSVpv(w_all->bits));
        _set_warn_bits("import", "", mask);
        mXPUSHs(mask);
        XSRETURN(1);
    }

void
unimport (klass, ...)
   SV* klass
PREINIT:
    SV *mask;
    int i;
    struct Perl_warnings *w_all = NULL;
PPCODE:
    if (!SvPOK(klass))
        croak_xs_usage(cv,  "class, ...");
    /* mask = ${^WARNING_BITS} // ($^W ? $Bits{all} : $DEFAULT); */
    if (specialWARN(PL_compiling.cop_warnings)) {
        if (PL_dowarn & G_WARN_ON || PL_compiling.cop_warnings == pWARN_ALL) {
            w_all = Perl_warnings_lookup("all", 3);
            mask = newWSVpv(w_all->bits);
        } else if (PL_compiling.cop_warnings == pWARN_NONE) {
            mask = newWSVpvh(WARN_NONEstring);
        } else {
            mask = newWSVpvh(WARN_DEFAULTstring);
        }
    } else
        mask = newSVpvn((char*)((STRLEN*)PL_compiling.cop_warnings+1), *PL_compiling.cop_warnings);

    if (IsSet(SvPVX(mask), 0)) {
        if (!w_all) w_all = Perl_warnings_lookup("all", 3);
        do_vop(OP_BIT_OR, mask, mask, newWSVpv(w_all->bits));
        if (IsSet(SvPVX(mask), 1))
            do_vop(OP_BIT_OR, mask, mask, newWSVpv(w_all->deadbits));
    }
    /* push @_, 'all' if !@_ || @_==1 && $_[0] eq 'FATAL'; */
    if ((items == 1) || (items == 2 && (SvPOK(ST(1)) && memEQs(SvPVX(ST(1)), SvCUR(ST(1)), "FATAL")))) {
        mPUSHs(newSVpvs("all"));
        ax--;
        items++;
    }
    for (i=1; i<items; i++) {
        SV *word = ST(i);
        if (!SvPOK(word)) continue;
        if (memEQs(SvPVX(word), SvCUR(word), "FATAL"))
            continue;
        else {
            const struct Perl_warnings *w = Perl_warnings_lookup(SvPVX(word), SvCUR(word));
            if (w) { /* $mask &= ~($catmask | $DeadBits{$word} | $All); */
                STRLEN j; U8 *p;
                SV *catmask = newWSVpv(w->bits);
                do_vop(OP_BIT_OR, catmask, catmask, newWSVpv(w->deadbits));
                do_vop(OP_BIT_OR, catmask, catmask, newWSVpvs("\3")); /* $All */
                for (p=(U8*)SvPVX(catmask), j=0; j<SvCUR(catmask); j++) {
                    const U8 c = *p;
                    *p++ = ~c;
                }
                do_vop(OP_BIT_AND, mask, mask, catmask);
                SvREFCNT_dec(catmask);
            } else {
                SV *msg = newSVpvs("Unknown warnings category '");
                sv_catsv(msg, word);
                sv_catpvs(msg, "'");
#ifdef USE_PP_CARP
                PUSHMARK(SP);
                mXPUSHs(msg);
                PUTBACK;
                call_pv("warnings::Croaker", G_DISCARD);
                SPAGAIN;
#else
                croak_sv(carp_shortmess(ax, msg));
#endif
            }
        }
    }
    _set_warn_bits("unimport", items > 1 ? SvPVX(ST(1)) : "", mask);
    mXPUSHs(mask);
    XSRETURN(1);

void
_chk (SV *sub, IV flags, ...)
PPCODE:
    if (_chk(SvPVX(sub), flags, ax+2))
        XSRETURN_YES;
    else
        XSRETURN_NO;

#if 0

void
enabled (...)
PPCODE:
    if (_chk("enabled", WNORMAL, ax))
        XSRETURN_YES;
    else
        XSRETURN_NO;

void
fatal_enabled (...)
PPCODE:
    if (_chk("fatal_enabled", WFATAL, ax))
        XSRETURN_YES;
    else
        XSRETURN_NO;

void
warn (...)
PPCODE:
    if (_chk("warn", WFATAL|WMESSAGE, ax))
        XSRETURN_YES;
    else
        XSRETURN_NO;

void
warnif (...)
PPCODE:
    if (_chk("warnif", WNORMAL|WFATAL|WMESSAGE, ax))
        XSRETURN_YES;
    else
        XSRETURN_NO;

#endif

void
register_categories (...)
PREINIT:
    int i;
PPCODE:
    /* check if name is registered (const key).
       if not, add key and also add bit to Bits{all} and DeadBits{all} */
    for (i=0; i<items; i++) {
        SV *name = ST(i);
        char* n;
        struct Perl_warnings *w;
        struct Perl_warnings_dyn *wd;
        STRLEN l = SvCUR(name);
        if (!SvPOK(name)) continue;
        n = SvPVX(name);
        w = Perl_warnings_lookup(n, l);
        if (!w) { /* oops, a new category. Add to dynamic %_Bits */
            HV * const bith = get_hv("warnings::_Bits", GV_ADD);
            SV **bit;
            if (!(bit = hv_fetch(bith, n, l, FALSE))) {
                SV *last_bitsv = get_sv("warnings::LAST_BIT", 0);
                IV last_bit = SvIVX(last_bitsv);
                SV *bytes = get_sv("warnings::BYTES", 0);
                IV offset = last_bit + 1;
                SV *bits = newWSVpvs("");
                SV *deadbits = newWSVpvs("");
                char *b = SvPVX(bits);
                char *d = SvPVX(deadbits);
                b[ Off(last_bit) ] |= Bit(last_bit);
                d[ Off(offset) ]   |= Bit(offset);
                sv_catsv(bits, deadbits);
                sv_upgrade(bits, SVt_PVIV);
                SvIV_set(bits, last_bit);
                hv_store_ent(bith, name, bits, 0);
                /* now extend "all" */
                wd = (struct Perl_warnings_dyn *)Perl_warnings_lookup("all", 3);
                wd->bits[ Off(last_bit) ]   |= Bit(last_bit);
                wd->deadbits[ Off(offset) ] |= Bit(offset);
                /* So far we go with a static length */
                /*Move(wd->deadbits, SvPVX(wd->base)+WARN_MAX_BYTES, WARN_MAX_BYTES, char);*/
                /* we dont resize this "all" SV, so no need to store it back */
                /*hv_stores(bith, "all", wd->base);*/
                SvIV_set(bits, last_bit);
                last_bit = offset + 1;
                if (Off(last_bit) > SvIVX(bytes)) {
                    SvIV_set(bytes, Off(last_bit));
                    if (Off(last_bit) > WARN_MAX_BYTES) /* This is a new cperl limitation */
                        croak("Internal error: Cannot register more than 255 warnings");
                }
                SvIV_set(last_bitsv, last_bit);
#ifdef DEBUGGING
                if (DEBUG_v_TEST_) {
                    SV *dsv = newSVpvn("", 80);
                    Perl_deb("warnings::register_categories %s %s\n", n,
                             pv_display( dsv, SvPVX(bits), WARN_MAX_BYTES, WARN_MAX_BYTES, 80));
                    Perl_deb(" all=%s, BYTES=%ld, LAST_BIT=%ld\n",
                             pv_display( dsv, wd->bits, WARN_MAX_BYTES, WARN_MAX_BYTES, 80),
                             SvIVX(bytes), last_bit);
                    SvREFCNT_dec(dsv);
                }
#endif
                /* we need to update ${^WARNING_BITS}/cop_warnings also? */
                /* _set_warn_bits("register_categories", n, newWSV(wd->bits, SvIVX(bytes))); */
            }
        }
    }
    XSRETURN_UNDEF;

void
keys()
PREINIT:
    int i;
    const int size = TOTAL_KEYWORDS;
    char *s = (char *)stringpool;
    HV * const bits = get_hv("warnings::_Bits", 0);
    I32 len = HvTOTALKEYS(bits);
PPCODE:
    /* Note: This is highly gperf dependent! */
    EXTEND(sp, size+len);
    for (i=0; i<size; i++) {
        int l = strlen(s);
        mPUSHp(s, l);
        s += l+1;
    }
    /* And now the dynamic bits */
    hv_iterinit(bits);
    for (i = 0; i < len; i++) {
        HE *he = hv_iternext(bits);
        SV *key = hv_iterkeysv(he);
        if (strnNE(SvPVX(key), "all", SvCUR(key)))
            PUSHs(key);
    }

void
exists(category)
         SV *category
PREINIT:
    const char *str = SvPVX(category);
    const IV len = SvCUR(category);
    const struct Perl_warnings *w = warnings_const_lookup(str, len);
PPCODE:
    if (!w) {
        SV **bit;
        HV * const bits = get_hv("warnings::_Bits", 0);
        if (bits && ((bit = hv_fetch(bits, str, len, FALSE)))) {
            XSRETURN_YES;
        }
    }
    XSRETURN_UNDEF;

BOOT:
{
    GV *last_bit = gv_fetchpv("warnings::LAST_BIT", GV_ADDMULTI, SVt_IV);
    GV *bytes    = gv_fetchpv("warnings::BYTES", GV_ADDMULTI, SVt_IV);
    HV * const bits = get_hv("warnings::_Bits", GV_ADD);
    SV *bits_all = newWSVpvh(WARN_ALLstring);
    sv_catsv(bits_all, newWSVpvh(WARN_DEADALLstring));
    sv_upgrade(bits_all, SVt_PVIV);
    SvIV_set(bits_all, 0);
    hv_store(bits, "all", 3, bits_all, 0);
    GvSV(last_bit) = newSViv(WARN_LAST_BIT);
    GvSV(bytes)    = newSViv(WARNsize);
}
